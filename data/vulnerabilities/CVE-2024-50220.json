{
	"name": "CVE-2024-50220",
	"description": "In the Linux kernel, the following vulnerability has been resolved:fork: do not invoke uffd on fork if error occursPatch series \"fork: do not expose incomplete mm on fork\".During fork we may place the virtual memory address space into aninconsistent state before the fork operation is complete.In addition, we may encounter an error during the fork operation thatindicates that the virtual memory address space is invalidated.As a result, we should not be exposing it in any way to external machinerythat might interact with the mm or VMAs, machinery that is not designed todeal with incomplete state.We specifically update the fork logic to defer khugepaged and ksm to theend of the operation and only to be invoked if no error arose, anddisallow uffd from observing fork events should an error have occurred.This patch (of 2):Currently on fork we expose the virtual address space of a process touserland unconditionally if uffd is registered in VMAs, regardless ofwhether an error arose in the fork.This is performed in dup_userfaultfd_complete() which is invokedunconditionally, and performs two duties - invoking registered handlersfor the UFFD_EVENT_FORK event via dup_fctx(), and clearing downuserfaultfd_fork_ctx objects established in dup_userfaultfd().This is problematic, because the virtual address space may not yet becorrectly initialised if an error arose.The change in commit d24062914837 (\"fork: use __mt_dup() to duplicatemaple tree in dup_mmap()\") makes this more pertinent as we may be in astate where entries in the maple tree are not yet consistent.We address this by, on fork error, ensuring that we roll back state thatwe would otherwise expect to clean up through the event being handled byuserland and perform the memory freeing duty otherwise performed bydup_userfaultfd_complete().We do this by implementing a new function, dup_userfaultfd_fail(), whichperforms the same loop, only decrementing reference counts.Note that we perform mmgrab() on the parent and child mm's, howeveruserfaultfd_ctx_put() will mmdrop() this once the reference count drops tozero, so we will avoid memory leaks correctly here.",
	"type": "none",
	"severity": "none",
	"state": "published",
	"references": [
		"https://git.kernel.org/stable/c/92b472945dbf8abc020e9259c0088026f7027dfc",
		"https://git.kernel.org/stable/c/f64e67e5d3a45a4a04286c47afade4b518acd47b",
		"https://project-zero.issues.chromium.org/issues/373391951"
	],
	"datetime": "2025-02-06 12:35:23",
	"connections": [],
	"devices": [],
	"distributions": [
		{
			"name": "debian",
			"version": "sid",
			"vendor": "debian-sid"
		},
		{
			"name": "debian",
			"version": "trixie",
			"vendor": "debian-trixie"
		},
		{
			"name": "debian",
			"version": "bookworm",
			"vendor": "debian-bookworm"
		},
		{
			"name": "debian",
			"version": "bullseye",
			"vendor": "debian-bullseye"
		}
	],
	"packages": [
		{
			"name": "linux",
			"version": "\u003c 6.11.7-1",
			"architecture": "any",
			"manager": "apt",
			"vendor": "debian-sid"
		},
		{
			"name": "linux",
			"version": "\u003c 6.1.123-1",
			"architecture": "any",
			"manager": "apt",
			"vendor": "debian-bookworm"
		},
		{
			"name": "linux",
			"version": "\u003c 5.10.223-1",
			"architecture": "any",
			"manager": "apt",
			"vendor": "debian-bullseye"
		}
	],
	"products": [],
	"programs": [],
	"weaknesses": []
}