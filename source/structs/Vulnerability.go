package structs

import "battlemap/matchers"
import "battlemap/types"
import utils_strings "battlemap/utils/strings"
import "strings"
import "time"

type Vulnerability struct {
	Name          string                  `json:"name"`
	Description   string                  `json:"description"`
	Type          string                  `json:"type"`
	Severity      string                  `json:"severity"`
	State         string                  `json:"state"`
	References    []string                `json:"references"`
	Datetime      types.Datetime          `json:"datetime"`
	Connections   []matchers.Connection   `json:"connections"`
	Devices       []matchers.Device       `json:"devices"`
	Distributions []matchers.Distribution `json:"distributions"`
	Packages      []matchers.Package      `json:"packages"`
	Products      []matchers.Product      `json:"products"`
	Programs      []matchers.Program      `json:"programs"`
	Weaknesses    []matchers.Weakness     `json:"weaknesses"`
}

func NewVulnerability() Vulnerability {

	var vulnerability Vulnerability

	vulnerability.Type = "none"
	vulnerability.Severity = "none"
	vulnerability.State = "invalid"
	vulnerability.References = make([]string, 0)
	vulnerability.SetDatetime(time.Now().Format(time.RFC3339))
	vulnerability.Connections = make([]matchers.Connection, 0)
	vulnerability.Distributions = make([]matchers.Distribution, 0)
	vulnerability.Devices = make([]matchers.Device, 0)
	vulnerability.Packages = make([]matchers.Package, 0)
	vulnerability.Products = make([]matchers.Product, 0)
	vulnerability.Programs = make([]matchers.Program, 0)
	vulnerability.Weaknesses = make([]matchers.Weakness, 0)

	return vulnerability

}

func (vulnerability *Vulnerability) IsValid() bool {

	if vulnerability.Name != "" && vulnerability.State != "invalid" {
		return true
	}

	return false

}

func (vulnerability *Vulnerability) MatchesConnection(connection types.Connection) bool {

	var result bool = false

	for c := 0; c < len(vulnerability.Connections); c++ {

		if vulnerability.Connections[c].Matches(connection.Source.Host, connection.Source.Port, connection.Protocol.String(), connection.Type) {
			result = true
			break
		} else if vulnerability.Connections[c].Matches(connection.Target.Host, connection.Target.Port, connection.Protocol.String(), connection.Type) {
			result = true
			break
		}

	}

	return result

}

func (vulnerability *Vulnerability) MatchesDistribution(distribution Distribution) bool {

	var result bool = false

	for d := 0; d < len(vulnerability.Distributions); d++ {

		if vulnerability.Distributions[d].Matches(distribution.Name, distribution.Version, distribution.Vendor) {
			result = true
			break
		}

	}

	return result

}

func (vulnerability *Vulnerability) MatchesPackage(pkg Package) bool {

	var result bool = false

	for p := 0; p < len(vulnerability.Packages); p++ {

		if vulnerability.Packages[p].Matches(pkg.Name, pkg.Version.String(), pkg.Manager.String(), pkg.Vendor) {
			result = true
			break
		}

	}

	return result

}

func (vulnerability *Vulnerability) MatchesProduct(product Product) bool {

	var result bool = false

	for p := 0; p < len(vulnerability.Products); p++ {

		if vulnerability.Products[p].Matches(product.Name, product.Version, product.Vendor, product.Type) {
			result = true
			break
		}

	}

	return result

}

func (vulnerability *Vulnerability) MatchesProgram(program Program) bool {

	var result bool = false

	for p := 0; p < len(vulnerability.Programs); p++ {

		if vulnerability.Programs[p].Matches(program.Name, program.Command) {
			result = true
			break
		}

	}

	return result

}

func (vulnerability *Vulnerability) MatchesWeakness(weakness Weakness) bool {

	var result bool = false

	for w := 0; w < len(vulnerability.Weaknesses); w++ {

		if vulnerability.Weaknesses[w].Matches(weakness.Name, weakness.Impacts, weakness.Scopes) {
			result = true
			break
		}

	}

	return result

}

func (vulnerability *Vulnerability) SetName(value string) {

	if strings.Contains(value, "-") {

		if strings.HasPrefix(value, "CVE-") {

			// CVE
			var tmp = strings.Split(value, "-")

			if len(tmp) == 3 && utils_strings.IsNumber(tmp[1]) && utils_strings.IsNumber(tmp[2]) {
				vulnerability.Name = value
			}

		} else if strings.HasPrefix(value, "ALSA-") {

			// Alma Linux
			var tmp = strings.Split(value, "-")

			if len(tmp) == 3 && utils_strings.IsNumber(tmp[1]) && utils_strings.IsNumber(tmp[2]) {
				vulnerability.Name = value
			}

		} else if strings.HasPrefix(value, "DLA-") || strings.HasPrefix(value, "DSA-") || strings.HasPrefix(value, "DTSA-") {

			// Debian
			var tmp = strings.Split(value, "-")

			if len(tmp) == 2 && utils_strings.IsNumber(tmp[1]) {
				vulnerability.Name = value
			} else if len(tmp) == 3 && utils_strings.IsNumber(tmp[1]) && utils_strings.IsNumber(tmp[2]) {
				vulnerability.Name = value
			}

		} else if strings.HasPrefix(value, "ELSA-") {

			// Oracle Linux
			var tmp = strings.Split(value, "-")

			if len(tmp) == 3 && utils_strings.IsNumber(tmp[1]) && utils_strings.IsNumber(tmp[2]) {
				vulnerability.Name = value
			}

		} else if strings.HasPrefix(value, "GLSA-") {

			// Gentoo
			var tmp = strings.Split(value, "-")

			if len(tmp) == 3 && len(tmp[1]) == 6 && utils_strings.IsNumber(tmp[1]) && len(tmp[2]) == 2 && utils_strings.IsNumber(tmp[2]) {
				vulnerability.Name = value
			}

		} else if strings.HasPrefix(value, "GHSA-") {

			// GitHub
			var tmp = strings.Split(value, "-")

			if len(tmp) == 4 && len(tmp[1]) == 4 && utils_strings.IsAlphabet(tmp[1]) && len(tmp[2]) == 4 && utils_strings.IsAlphabet(tmp[2]) && len(tmp[3]) == 4 && utils_strings.IsAlphabet(tmp[3]) {
				vulnerability.Name = value
			}

		} else if strings.HasPrefix(value, "LSN-") || strings.HasPrefix(value, "USN-") {

			// Ubuntu
			var tmp = strings.Split(value, "-")

			if len(tmp) == 3 && utils_strings.IsNumber(tmp[1]) && utils_strings.IsNumber(tmp[2]) {
				vulnerability.Name = value
			}

		} else if strings.HasPrefix(value, "RLBA-") || strings.HasPrefix(value, "RLEA-") || strings.HasPrefix(value, "RLSA-") {

			// Rocky Linux
			var tmp = strings.Split(value, "-")

			if len(tmp) == 3 && utils_strings.IsNumber(tmp[1]) && utils_strings.IsNumber(tmp[2]) {
				vulnerability.Name = value
			}

		}

	}

}

func (vulnerability *Vulnerability) SetDescription(value string) {

	filtered := utils_strings.ToASCII(value)

	if len(filtered) > 0 {
		vulnerability.Description = filtered
	}

}

func (vulnerability *Vulnerability) AddType(value string) {

	var current = vulnerability.Type

	if current == "none" {

		vulnerability.SetType(value)

	} else if current == "physical" {

		if value == "local" || value == "adjacent" || value == "network" {
			vulnerability.SetType(value)
		}

	} else if current == "local" {

		if value == "adjacent" || value == "network" {
			vulnerability.SetType(value)
		}

	} else if current == "adjacent" {

		if value == "network" {
			vulnerability.SetType(value)
		}

	} else if current == "network" {
		// Do Nothing
	}

}

func (vulnerability *Vulnerability) SetType(value string) {

	if value == "none" {
		vulnerability.Type = "none"
	} else if value == "physical" {
		vulnerability.Type = "physical"
	} else if value == "local" {
		vulnerability.Type = "local"
	} else if value == "adjacent" {
		vulnerability.Type = "adjacent"
	} else if value == "network" {
		vulnerability.Type = "network"
	}

}

func (vulnerability *Vulnerability) AddSeverity(value string) {

	var current = vulnerability.Severity

	if current == "none" {

		vulnerability.SetSeverity(value)

	} else if current == "low" {

		if value == "medium" || value == "high" || value == "critical" {
			vulnerability.SetSeverity(value)
		}

	} else if current == "medium" {

		if value == "high" || value == "critical" {
			vulnerability.SetSeverity(value)
		}

	} else if current == "high" {

		if value == "critical" {
			vulnerability.SetSeverity(value)
		}

	} else if current == "critical" {
		// Do Nothing
	}

}

func (vulnerability *Vulnerability) SetSeverity(value string) {

	if value == "none" {
		vulnerability.Severity = "none"
	} else if value == "low" {
		vulnerability.Severity = "low"
	} else if value == "medium" {
		vulnerability.Severity = "medium"
	} else if value == "high" {
		vulnerability.Severity = "high"
	} else if value == "critical" {
		vulnerability.Severity = "critical"
	}

}

func (vulnerability *Vulnerability) AddState(value string) {

	var current = vulnerability.State

	if current == "none" || current == "invalid" {

		vulnerability.SetState(value)

	} else if current == "reversed" || current == "rejected" || current == "disputed" {

		if value == "published" || value == "edited" {
			vulnerability.SetState(value)
		}

	} else if current == "published" {

		if value == "edited" {
			vulnerability.SetState(value)
		}

	} else if current == "edited" {
		// Do Nothing
	}

}

func (vulnerability *Vulnerability) SetState(value string) {

	if value == "edited" {
		vulnerability.State = "edited"
	} else if value == "published" {
		vulnerability.State = "published"
	} else if value == "disputed" {
		vulnerability.State = "disputed"
	} else if value == "rejected" {
		vulnerability.State = "rejected"
	} else if value == "reserved" {
		vulnerability.State = "reserved"
	} else if value == "invalid" {
		vulnerability.State = "invalid"
	}

}

func (vulnerability *Vulnerability) AddDatetime(value string) {

	datetime := types.ToDatetime(value)

	if datetime.IsValid() && datetime.IsBefore(vulnerability.Datetime) {
		vulnerability.Datetime = datetime
	}

}

func (vulnerability *Vulnerability) SetDatetime(value string) {

	datetime := types.ToDatetime(value)

	if datetime.IsValid() {
		vulnerability.Datetime = datetime
	}

}

func (vulnerability *Vulnerability) AddConnection(value matchers.Connection) {

	if value.IsValid() {

		var found bool = false

		for c := 0; c < len(vulnerability.Connections); c++ {

			if vulnerability.Connections[c].IsIdentical(value) {
				found = true
				break
			}

		}

		if found == false {
			vulnerability.Connections = append(vulnerability.Connections, value)
		}

	}

}

func (vulnerability *Vulnerability) RemoveConnection(value matchers.Connection) {

	var index int = -1

	for c := 0; c < len(vulnerability.Connections); c++ {

		if vulnerability.Connections[c].IsIdentical(value) {
			index = c
			break
		}

	}

	if index != -1 {
		vulnerability.Connections = append(vulnerability.Connections[:index], vulnerability.Connections[index+1:]...)
	}

}

func (vulnerability *Vulnerability) SetConnections(value []matchers.Connection) {

	var filtered []matchers.Connection

	for v := 0; v < len(value); v++ {

		if value[v].IsValid() {
			filtered = append(filtered, value[v])
		}

	}

	vulnerability.Connections = filtered

}

func (vulnerability *Vulnerability) AddDistribution(value matchers.Distribution) {

	if value.IsValid() {

		var found bool = false

		for d := 0; d < len(vulnerability.Distributions); d++ {

			if vulnerability.Distributions[d].IsIdentical(value) {
				found = true
				break
			}

		}

		if found == false {
			vulnerability.Distributions = append(vulnerability.Distributions, value)
		}

	}

}

func (vulnerability *Vulnerability) RemoveDistribution(value matchers.Distribution) {

	var index int = -1

	for d := 0; d < len(vulnerability.Distributions); d++ {

		if vulnerability.Distributions[d].IsIdentical(value) {
			index = d
			break
		}

	}

	if index != -1 {
		vulnerability.Distributions = append(vulnerability.Distributions[:index], vulnerability.Distributions[index+1:]...)
	}

}

func (vulnerability *Vulnerability) SetDistributions(value []matchers.Distribution) {

	var filtered []matchers.Distribution

	for v := 0; v < len(value); v++ {

		if value[v].IsValid() {
			filtered = append(filtered, value[v])
		}

	}

	vulnerability.Distributions = filtered

}

func (vulnerability *Vulnerability) AddDevice(value matchers.Device) {

	if value.IsValid() {

		var found bool = false

		for d := 0; d < len(vulnerability.Devices); d++ {

			if vulnerability.Devices[d].IsIdentical(value) {
				found = true
				break
			}

		}

		if found == false {
			vulnerability.Devices = append(vulnerability.Devices, value)
		}

	}

}

func (vulnerability *Vulnerability) RemoveDevice(value matchers.Device) {

	var index int = -1

	for d := 0; d < len(vulnerability.Devices); d++ {

		if vulnerability.Devices[d].IsIdentical(value) {
			index = d
			break
		}

	}

	if index != -1 {
		vulnerability.Devices = append(vulnerability.Devices[:index], vulnerability.Devices[index+1:]...)
	}

}

func (vulnerability *Vulnerability) SetDevices(value []matchers.Device) {

	var filtered []matchers.Device

	for v := 0; v < len(value); v++ {

		if value[v].IsValid() {
			filtered = append(filtered, value[v])
		}

	}

	vulnerability.Devices = filtered

}

func (vulnerability *Vulnerability) AddPackage(value matchers.Package) {

	if value.IsValid() {

		var found bool = false

		for p := 0; p < len(vulnerability.Packages); p++ {

			if vulnerability.Packages[p].IsIdentical(value) {
				found = true
				break
			}

		}

		if found == false {
			vulnerability.Packages = append(vulnerability.Packages, value)
		}

	}

}

func (vulnerability *Vulnerability) RemovePackage(value matchers.Package) {

	var index int = -1

	for p := 0; p < len(vulnerability.Packages); p++ {

		if vulnerability.Packages[p].IsIdentical(value) {
			index = p
			break
		}

	}

	if index != -1 {
		vulnerability.Packages = append(vulnerability.Packages[:index], vulnerability.Packages[index+1:]...)
	}

}

func (vulnerability *Vulnerability) SetPackages(value []matchers.Package) {

	var filtered []matchers.Package

	for v := 0; v < len(value); v++ {

		if value[v].IsValid() {
			filtered = append(filtered, value[v])
		}

	}

	vulnerability.Packages = filtered

}

func (vulnerability *Vulnerability) AddProduct(value matchers.Product) {

	if value.IsValid() {

		var found bool = false

		for p := 0; p < len(vulnerability.Products); p++ {

			if vulnerability.Products[p].IsIdentical(value) {
				found = true
				break
			}

		}

		if found == false {
			vulnerability.Products = append(vulnerability.Products, value)
		}

	}

}

func (vulnerability *Vulnerability) RemoveProduct(value matchers.Product) {

	var index int = -1

	for p := 0; p < len(vulnerability.Products); p++ {

		if vulnerability.Products[p].IsIdentical(value) {
			index = p
			break
		}

	}

	if index != -1 {
		vulnerability.Products = append(vulnerability.Products[:index], vulnerability.Products[index+1:]...)
	}

}

func (vulnerability *Vulnerability) SetProducts(value []matchers.Product) {

	var filtered []matchers.Product

	for v := 0; v < len(value); v++ {

		if value[v].IsValid() {
			filtered = append(filtered, value[v])
		}

	}

	vulnerability.Products = filtered

}

func (vulnerability *Vulnerability) AddProgram(value matchers.Program) {

	if value.IsValid() {

		var found bool = false

		for p := 0; p < len(vulnerability.Programs); p++ {

			if vulnerability.Programs[p].IsIdentical(value) {
				found = true
				break
			}

		}

		if found == false {
			vulnerability.Programs = append(vulnerability.Programs, value)
		}

	}

}

func (vulnerability *Vulnerability) RemoveProgram(value matchers.Program) {

	var index int = -1

	for p := 0; p < len(vulnerability.Programs); p++ {

		if vulnerability.Programs[p].IsIdentical(value) {
			index = p
			break
		}

	}

	if index != -1 {
		vulnerability.Programs = append(vulnerability.Programs[:index], vulnerability.Programs[index+1:]...)
	}

}

func (vulnerability *Vulnerability) SetPrograms(value []matchers.Program) {

	var filtered []matchers.Program

	for v := 0; v < len(value); v++ {

		if value[v].IsValid() {
			filtered = append(filtered, value[v])
		}

	}

	vulnerability.Programs = filtered

}

func (vulnerability *Vulnerability) AddReference(value string) {

	if strings.HasPrefix(value, "http://") || strings.HasPrefix(value, "https://") {

		var found bool = false

		for r := 0; r < len(vulnerability.References); r++ {

			if vulnerability.References[r] == value {
				found = true
				break
			}

		}

		if found == false {
			vulnerability.References = append(vulnerability.References, value)
		}

	}

}

func (vulnerability *Vulnerability) RemoveReference(value string) {

	var index int = -1

	for r := 0; r < len(vulnerability.References); r++ {

		if vulnerability.References[r] == value {
			index = r
			break
		}

	}

	if index != -1 {
		vulnerability.References = append(vulnerability.References[:index], vulnerability.References[index+1:]...)
	}

}

func (vulnerability *Vulnerability) SetReferences(values []string) {

	var filtered []string

	for v := 0; v < len(values); v++ {

		var value = values[v]

		if strings.HasPrefix(value, "http://") || strings.HasPrefix(value, "https://") {
			filtered = append(filtered, value)
		}

	}

	vulnerability.References = filtered

}

func (vulnerability *Vulnerability) AddWeakness(value matchers.Weakness) {

	if value.IsValid() {

		var found bool = false

		for w := 0; w < len(vulnerability.Weaknesses); w++ {

			if vulnerability.Weaknesses[w].IsIdentical(value) {
				found = true
				break
			}

		}

		if found == false {
			vulnerability.Weaknesses = append(vulnerability.Weaknesses, value)
		}

	}

}

func (vulnerability *Vulnerability) RemoveWeakness(value matchers.Weakness) {

	var index int = -1

	for w := 0; w < len(vulnerability.Weaknesses); w++ {

		if vulnerability.Weaknesses[w].IsIdentical(value) {
			index = w
			break
		}

	}

	if index != -1 {
		vulnerability.Weaknesses = append(vulnerability.Weaknesses[:index], vulnerability.Weaknesses[index+1:]...)
	}

}

func (vulnerability *Vulnerability) SetWeaknesses(value []matchers.Weakness) {

	var filtered []matchers.Weakness

	for v := 0; v < len(value); v++ {

		if value[v].IsValid() {
			filtered = append(filtered, value[v])
		}

	}

	vulnerability.Weaknesses = filtered

}
