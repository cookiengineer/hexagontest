<!DOCTYPE html><html lang="en">
<head>

<meta charset="utf-8">
<title>Implementation of A*</title>
<link rel="canonical" href="https://www.redblobgames.com/pathfinding/a-star/implementation.html">
<!--DO NOT EDIT: generated from redblobgames/pathfinding/a-star/implementation.bxml-->
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="preload" as="image" href="/img/transparent-blob.png">
<link rel="alternate" type="application/atom+xml" title="Blog posts" href="https://www.redblobgames.com/blog/posts.xml">
<meta name="theme-color" content="hsl(0,50%,45%)">
<script src="implementation.js?2022-10-18-10-33-33" defer></script><style>:root{--hue: 0;--bgurl: url("/img/transparent-blob.png")}/*! CSS Copyright 2007-2023 by amitp@cs.stanford.edu (Amit J. Patel)  *//*! I don't mind if you copy my stylesheet.  However, I'd appreciate it if you gave me credit. */body{--serif: "Iowan Old Style",Cambria,Georgia,serif;--sans-serif: "Avenir Next",Candara,Ubuntu,"Fira Sans",system-ui,"Segoe UI",sans-serif;--monospace: "Roboto Mono","Cascadia Code",Consolas,monospace,"Segoe UI Symbol",Symbol;--body-width: calc(100vw - 2.25rem);--font-size: calc(0.625rem + 1vw);--line-height: calc(1.5 * var(--font-size));font-family:var(--sans-serif);font-size:var(--font-size);line-height:1.5em;min-height:95%}@media (min-width: 34.375em){body{--body-width: min(20.6rem + 33vw, 41.25rem);--font-size: calc(var(--body-width) / 33)}}main{font-family:var(--serif)}h1,h2,h3,h4,h5,h6,figcaption,.sans-serif{font-family:var(--sans-serif);text-wrap:balance}tt,code,kbd,samp,pre{font-family:var(--monospace);font-size:0.8em}pre :is(tt, code, kbd, samp){font-size:unset}#table-of-contents{background-color:#fff;padding-left:1em;width:18em;float:right}#table-of-contents:after{clear:right}nav,#table-of-contents{font-family:var(--sans-serif);font-size:calc(var(--font-size) / 1.25)}nav a,#table-of-contents a{text-decoration-color:hsl(var(--hue), 20%, 90%)}@media screen{header,section>h2{text-shadow:0px 2px 5px rgba(0,0,0,0.8);text-rendering:optimizeLegibility}}h1{font-size:2.0em;margin:0;line-height:calc(1.5 * var(--line-height))}h1 .subheading{font-size:0.5em;line-height:var(--line-height)}sup,sub{position:relative;vertical-align:baseline;font-size:0.75em;line-height:0;padding-left:0.125em}sup{top:-0.5em}sub{bottom:-0.25em}details summary{cursor:pointer}*{box-sizing:border-box}html,body{margin:0;padding:0}html{background-color:#e4e4e0;color:#000}body{background-color:#fff;color:#333}header{display:block;text-align:center}header>h1{padding-top:var(--line-height)}@media screen{header,footer,.divider,section>h2{color:#fff;background-color:hsl(var(--hue), 50%, 45%);background-image:var(--bgurl), var(--bgurl), linear-gradient(180deg, hsl(var(--hue), 50%, 45%) 0%, hsl(var(--hue), 75%, 30%) 100%);background-position:0 0, 16px 16px;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}header a,footer a,.divider a,section>h2 a{color:hsl(var(--hue), 40%, 90%);background:unset;text-decoration:none}header a:hover,footer a:hover,.divider a:hover,section>h2 a:hover{background-color:rgba(0,0,0,0.5);text-decoration:underline}}footer a,.divider a{text-decoration:underline}main{margin-inline:0;padding-inline:0}section{margin:var(--line-height) 0}section>*{width:var(--body-width);max-width:100%}.comments{width:calc(1.5 * var(--body-width));max-width:100%}@media screen{.comments,.below-divider{background-color:#e6e6e5}}.comments{padding-bottom:1.25em;font-size:1.0em}.comments .comment-author{text-shadow:1px 1px 3px #fff}section>h2{--h2-margin: 3em;margin:var(--line-height) auto;padding:calc(var(--line-height) / 2 - 1px) 0;font-size:1.25em;width:calc(2 * var(--h2-margin) + var(--body-width));max-width:100%}section>h2>span{display:inline-block;margin-left:var(--h2-margin)}section>h2 a.anchor{float:right;width:calc(var(--h2-margin));text-align:center;color:hsl(var(--hue), 50%, 45%)}section>h2:hover a.anchor{color:hsl(var(--hue), 20%, 80%)}h3{--h2-margin: 3em;margin:var(--line-height) auto;font-size:1.125em}h3 a.anchor{float:right;width:calc(var(--h2-margin));text-align:center;color:hsl(var(--hue), 20%, 80%)}@media (min-width: 34.375em){h3 a.anchor{margin-right:calc(0em - var(--h2-margin))}}h4 a.anchor,h5 a.anchor,h6 a.anchor{padding-left:1em;color:hsl(var(--hue), 20%, 80%)}h3:hover a.anchor,h4:hover a.anchor,h5:hover a.anchor,h6:hover a.anchor{color:hsl(var(--hue), 50%, 40%)}header nav{display:block}header nav ul{display:flex;flex-flow:row wrap;justify-content:center;line-height:1.0;margin:0}header nav ul li{display:inline-block;padding:0.1em 0.3em;text-align:center;flex:0 0 4em;align-self:center;white-space:nowrap}header nav ul li a{display:block;font-weight:bold;text-decoration:none}header,.divider,section>h2{border-bottom:1px solid #000}.divider,section>h2{border-top:1px solid #000}.divider{min-height:calc(2 * var(--line-height));text-align:center}.below-divider{padding-top:var(--line-height);border-bottom:1px solid black}.below-divider>p:first-child{font-size:1.25em;text-align:center;margin-top:0}footer{--footer-padding-y: calc(var(--line-height) / 2);--footer-padding-x: var(--font-size);padding:var(--footer-padding-y) var(--footer-padding-x);border-top:1px solid #000}footer>div>address{display:block}footer>div>*{text-align:center}@media (min-width: 50em){footer>div{margin:0 auto;display:flex;flex-flow:row wrap;justify-content:center;max-width:calc(2 * var(--body-width));width:calc(100vw - 2 * var(--footer-padding-x))}footer>div>address{flex:0 1 20em;align-self:center;text-align:left}footer>div>div{flex:1 1 20em;align-self:center;text-align:right}footer>div>div>p,footer>div>div>div{margin-top:0}}h2:target{animation:target-attention 0.4s 1;font-size:2.0em}@keyframes target-attention{0%{transform:scale(1.1)}100%{transform:scale(1.1)}}div:target{border:1px dashed #888}kbd kbd{padding:0.1em 0.4em;margin:0 0.1em 0.2em 0.1em;font-size:0.75em;white-space:nowrap;background-color:#ddd;color:#242;border:1px solid rgba(0,0,0,0.2);border-radius:0.2em;box-shadow:inset 0 0 1px 1px #fff,0 2px 0 rgba(0,0,0,0.3)}samp,kbd{background-color:#f3f3f2}code,samp{color:#442}kbd{margin:0 0.4em;color:#252}section li::marker{font-family:var(--sans-serif);color:hsl(var(--hue), 50%, 40%)}img{max-width:100%;height:auto;-ms-interpolation-mode:bicubic}section figcaption{font-size:0.75em;line-height:1.1;text-align:center}a{color:hsl(var(--hue), 50%, 45%);text-decoration-color:hsl(var(--hue), 20%, 80%);text-underline-offset:0.25em}a:hover{text-decoration:underline;text-decoration-color:hsl(var(--hue), 50%, 45%);background:hsla(var(--hue), 50%, 50%, 0.1)}:focus-visible{outline-color:hsl(var(--hue), 50%, 45%)}.draft{font-family:var(--serif);font-size:calc(4 * var(--font-size));letter-spacing:-0.1em;color:#eee;opacity:0.5;text-align:center;transform:rotate(-5deg);line-height:1.0;position:absolute;top:0;height:0;left:25%;width:50%;pointer-events:none}@media (min-width: 34.375em){section p,section li{hanging-punctuation:first last;text-wrap:pretty;hyphens:auto;hyphenate-limit-chars:7}}nav,.section-number,address,time{font-variant-numeric:oldstyle-nums}.w-auto,section>.w-auto{width:auto}.w-full,section>.w-full{width:100%}.w-150b,section>.w-150b{width:calc(1.5 * var(--body-width))}.select-none{user-select:none;-webkit-user-select:none}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}.text-sm{font-size:0.875em}.font-sans{font-family:var(--sans-serif)}.font-serif{font-family:var(--serif)}.font-mono{font-family:var(--monospace)}.normal-nums{font-variant-numeric:normal}.oldstyle-nums{font-variant-numeric:oldstyle-nums}p,figure,ul,ol{margin:var(--line-height) 0}header>*,section>*,footer>*,main>address,.comments{margin-inline:auto}figure{text-align:center}figure pre{text-align:left}li>ul,li>ol{margin-top:0;margin-bottom:0}figure img,figure svg,figure canvas{max-width:100%}dt{font-weight:bold}pre{width:var(--body-width);max-width:100%;line-height:1.4;overflow:auto;border-block:1px solid #ccc;border-inline-width:0}pre.simple,.comments pre{overflow:auto;width:calc(var(--body-width) * 1.2);border:none;background:transparent;background-color:transparent;box-shadow:none}pre.snippet,pre.src{border-top-style:dashed;border-bottom-style:dashed}section>pre:only-child{padding-bottom:var(--font-size);border-bottom:1px solid rgba(0,0,0,0.5)}blockquote{font-style:italic;text-wrap:balance}table.standard2024{font-family:var(--sans-serif);font-size:0.875em;border:2px solid white;border-collapse:collapse;overflow-x:auto}table.standard2024 th{background-color:#e8e8e3;border:2px solid white;padding:0 0.5em}table.standard2024 td{background-color:#fff;border:1px solid #f3f3f2;border-right-color:#babaab;padding:0 0.5em}table.standard2024 thead{border-bottom:2px solid #babaab}table.standard2024 thead th{background:linear-gradient(to top, #e8e8e3, #f4f4f1, #fafaf9)}table.standard{font-family:var(--sans-serif);font-size:0.875em;border-block:2px solid hsl(var(--hue), 10%, 50%);border-collapse:collapse;overflow-x:auto;text-align:left}table.standard td,table.standard th{border-bottom:1px solid #f3f3f2;padding:0 0.5em}table.standard :is(td, th):not(:last-child){border-right:1px solid #babaab}table.standard td{background-color:hsl(var(--hue), 10%, 97%);border-bottom-color:white}table.standard thead{border-bottom:2px solid hsl(var(--hue), 10%, 50%);vertical-align:bottom}table.standard tfoot{border-top:2px solid hsl(var(--hue), 10%, 50%);vertical-align:bottom}table.standard thead th{background:linear-gradient(to top, hsl(var(--hue), 10%, 85%), hsl(var(--hue), 15%, 87%), hsl(var(--hue), 15%, 90%));border-bottom:unset}table.standard tbody th{background-color:hsl(var(--hue), 10%, 95%);border-bottom:1px solid white}table.standard tr:hover :is(td, th){background-color:hsl(var(--hue), 25%, 93%)}aside,p.note,div.note>p{width:calc(--body-width - 2em);padding:1em;background:#eee;border:1px solid #ddd;box-shadow:0 8px 6px -6px rgba(0,0,0,0.4)}tt,code{padding:0 2px}pre :is(tt, code){padding:unset}main>address,section>address,section>time{display:block;width:var(--body-width);max-width:100%;font-family:var(--sans-serif);text-align:right}form{margin:0}input{accent-color:hsl(var(--hue), 50%, 50%)}input[type="text"]{max-width:100%;border:1px solid rgba(0,0,0,0.7);background-color:#f8f8f4;color:#000;text-align:center;font-weight:bold}input[type="text"]:focus{background-color:#fffff4}input::placeholder{color:#aaa}input[type="search"][name="q"]{box-shadow:inset 0 0.1em 0.3em 0 rgba(0,0,0,0.5);border-radius:0.6em;padding:0.3em 0.6em;border-width:0}button{touch-action:manipulation;cursor:pointer;user-select:none}.TODO{color:#bf4040;background:#e8e3e3;border:1px solid #bf4040;margin-left:0.5ex}.DONE{color:#4040bf;background:#e3e3e8;border:1px solid #4040bf}.src .constant{font-style:oblique}.src .comment-delimiter,.src .nxml-comment-delimiter{color:#4488ff}.src .comment,.src .nxml-comment-content{color:#006699}.src .builtin{color:#508b20}.src .warning{color:#cc0000}.src .function-name{color:#268bd2;font-weight:bold}.src .variable-name{font-weight:bold;color:#5c3d5c}.src .type{color:#6c71c4}.src .constant-face{color:#d33682}.src .doc{color:#666666;background-color:#e2e6e8}.src .string{color:#888888}.src .preprocessor{color:#859900}.src .negation-char,.src .sh-escaped-newline{color:#ff0000}.src .todo{color:#ffffff;background:#dc322f}.src .note{color:#ffffff;background:#2aa198}.src .hack{color:#ffffff;background:#859900}.src .operator{color:black;font-weight:bold}.src .paren{color:#a0a090;font-weight:bold}.src .keyword{color:#679;font-weight:bold}.src .minor-control-construct{color:#406abf;font-weight:bold}.src .major-control-construct{color:#bf4040}.src-cpp .constant{color:#999999}.src-emacs-lisp .paren{color:#c9c9c4}.src-sh .string,.src-sh .comment{color:inherit}.src-python .highlight-indentation{border-right:2px solid #eeeeee}.src-css .css-selector{color:#478547}.src-css .css-property{color:#406abf}.src-xml .nxml-element-prefix{color:#bf40bf}.src-xml .nxml-element-local-name{color:#406abf;font-weight:normal}.src-xml .nxml-attribute-local-name{color:#478547}.src-xml .nxml-element-colon{color:#a3adc2}.src-xml .nxml-tag-delimiter,.src-xml .nxml-tag-slash{color:#9cabc9;font-weight:bold}table.standard td.left,table.standard th.left{text-align:left}table.standard td.center,table.standard th.center{text-align:center}table.standard td.right,table.standard th.right{text-align:right}@media screen{*[class^="section-number"]{color:hsl(var(--hue), 20%, 50%)}h2 .section-number{display:inline-block;margin-left:0;padding-left:0.5em;text-align:center;width:var(--h2-margin);color:hsl(var(--hue), 50%, 80%)}h2 .section-number+span{margin-left:0}h3>.section-number{float:left;text-align:center;width:2.7em;margin-right:0.3em;color:hsl(var(--hue), 25%, 90%);background:hsl(var(--hue), 50%, 50%);background-image:var(--bgurl), var(--bgurl);background-position:0 0, 16px 16px;border-radius:0.25em;text-shadow:0px 2px 5px rgba(0,0,0,0.8)}}@media screen and (min-width: 34.375em){h3>.section-number{height:2em;margin-left:-3em;margin-top:-0.3em;padding-top:0.3em;border-block:1px solid black}h3>a.anchor{background:url(https://www.redblobgames.com/img/svg-blob-mini.svg) no-repeat center center;background-size:2cap 2cap}h3:hover>a.anchor{background:none}}.print-endnote{display:none}@media print{@page{margin:0.5in}body{--font-size: 14pt;--serif: "Book Antiqua", "Times New Roman", serif;--sans-serif: "Helvetica", sans-serif;--monospace: "Courier", "Courier New", monospace}h2,h3{page-break-after:avoid}figure{page-break-inside:avoid}p,li{orphans:5;widows:5}section p a,section li a{text-decoration:underline;text-decoration-color:#ddd}header nav,.comments{display:none}.print-endnote{display:unset}.print-endnote li{list-style-type:none;word-break:break-all}.print-endnote img{width:2.5em;vertical-align:bottom}}

@media print{header::before{position:absolute;right:0;top:0;content:url(https://chart.apis.google.com/chart?chs=120x120&cht=qr&chl=https%3A%2F%2Fwww.redblobgames.com%2Fpathfinding%2Fa-star%2Fimplementation.html);}}
	  
    /* Need 80 columns for code, 90 for output, and with these extra margins it was too small, so I decreased font size. */
    pre {
        font-size: 0.8em;
        letter-spacing: -0.05em;
    }
    pre.src {
        white-space: pre;
        border: 0.5em solid hsl(60, 20%, 95%);
        padding: 0.5em 1em;
        margin-bottom: 0;
        box-shadow: inset 0 0 0.125em 1px hsla(60, 10%, 50%, 0.5);
    }
    pre.example {
        font-size: 0.7em;
        line-height: 1.2;
        background: hsl(60, 20%, 95%);
        padding-left: 1em;
        padding-bottom: 0.25em;
        border-top: none;
        border-bottom: none;
        white-space: pre;
    }

    /* "Syntax highlighting" for output ascii grids */
    pre.example span { display: inline-block; width: 2.75ch; text-align: center; color: hsl(220, 10%, 50%); }
    pre.example strong { background: hsl(30, 20%, 85%); color: hsl(30, 20%, 60%); }
    pre.example b { background: hsl(180, 20%, 85%); }
    pre.example i { background: hsl(180, 100%, 80%); }

    /* Make the code sections wider to handle 80 columns */
    section > .org-src-container, .org-src-container + pre.example {
        width: calc(1.1 * var(--body-width));
    }
    .org-src-container > pre {
        width: unset;
    }

    /* Remove the margin between the input and output sections */
    .org-src-container + pre.example {
        margin-top: 0;
    }
</style>
<script>function $l(s,e,d){d=document;if(d.location.hostname!='localhost'){e=d.createElement('script');e.async=true;e.src=s;e.dataset.timestamp=+new Date();d.body.appendChild(e)}}</script>
</head>
<body class="gameprog">
<header><h1>Implementation of A*</h1>
<div class="subheading">
                 from <a href="https://www.redblobgames.com/">Red Blob Games</a>
</div>
<nav><search><form action="https://www.google.com/search">
<ul> <li><a href="https://www.redblobgames.com/">Home</a></li> <li><a href="https://www.redblobgames.com/blog/">Blog</a></li> <li><a href="https://pinboard.in/u:amitp/t:gamedev/">Links</a></li> <li><a href="https://bsky.app/profile/redblobgames.com">Bluesky</a></li> <li><a rel="me" href="http://www-cs-students.stanford.edu/~amitp/">About</a></li> <li> </li> <li><input type="search" name="q" placeholder="Search" size="8"></li>
</ul>
<input type="hidden" name="hq" value="site:www.redblobgames.com OR site:theory.stanford.edu/~amitp/ OR site:www-cs-students.stanford.edu/~amitp/ OR site:amitp.blogspot.com OR site:simblob.blogspot.com">
</form></search></nav></header><main><nav id="table-of-contents" role="doc-toc"><h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc"><ul>
<li>
<a href="#python">1. Python Implementation</a><ul>
<li><a href="#python-breadth-first">1.1. Breadth First Search</a></li>
<li><a href="#python-early-exit">1.2. Early Exit</a></li>
<li><a href="#python-dijkstra">1.3. Dijkstra’s Algorithm</a></li>
<li><a href="#python-astar">1.4. A* Search</a></li>
</ul>
</li>
<li>
<a href="#cpp">2. C++ Implementation</a><ul>
<li><a href="#cpp-breadth-first">2.1. Breadth First Search</a></li>
<li><a href="#cpp-early-exit">2.2. Early Exit</a></li>
<li><a href="#cpp-dijkstra">2.3. Dijkstra’s Algorithm</a></li>
<li><a href="#cpp-astar">2.4. A* Search</a></li>
<li><a href="#cpp-production">2.5. Production code</a></li>
</ul>
</li>
<li><a href="#csharp">3. C# Implementation</a></li>
<li><a href="#algorithm">4. Algorithm changes</a></li>
<li>
<a href="#optimizations">5. Optimizations</a><ul>
<li><a href="#optimize-graph">5.1. Graph</a></li>
<li><a href="#optimize-bfs-queue">5.2. Queue</a></li>
<li><a href="#optimize-queue">5.3. Priority Queue</a></li>
<li><a href="#optimize-search">5.4. Search</a></li>
<li><a href="#optimize-integer-ids">5.5. Integer locations</a></li>
</ul>
</li>
<li>
<a href="#troubleshooting">6. Troubleshooting</a><ul>
<li><a href="#troubleshooting-wrong-path">6.1. Wrong paths</a></li>
<li><a href="#troubleshooting-ugly-path">6.2. Ugly paths</a></li>
</ul>
</li>
<li><a href="#terminology">7. Vocabulary</a></li>
<li><a href="#more">8. More reading</a></li>
</ul></div></nav><section><address>Jul 2014, then Feb 2016, Nov 2018, Oct 2020, Feb 2022</address>
<div class="note" id="org6caaaa3"><p>This article is a companion guide to my <a href="./introduction.html">introduction to A*</a>, where I explain how the algorithms work. On this page I show how to implement Breadth-First Search, Dijkstra’s Algorithm, Greedy Best-First Search, and A*. I try to keep the code here simple.</p></div>
<p>Graph search is a family of related algorithms. There are <em>lots</em> of variants of the algorithms, and lots of variants in implementation. Treat the code on this page as a starting point, not as a final version of the algorithm that works for all situations.</p></section><section><h2 id="python">
<span class="section-number"> 1  </span><span><a href="#python"> Python Implementation</a></span><a class="anchor" href="#python">#</a>
</h2>
<p>I explain most of the code below. There are a few extra bits that you can find in <a href="./implementation.py">implementation.py</a>. These use <strong>Python 3</strong> so if you use Python 2, you will need to remove type annotations, change the <code>super()</code> call, and change the <code>print</code> function to work with Python 2.</p>
<h3 id="python-breadth-first">
<span class="section-number"> 1.1 </span><span>Breadth First Search</span><a class="anchor" aria-hidden="true" href="#python-breadth-first">#</a>
</h3>
<p>Let’s implement Breadth First Search in Python. The main article shows the Python code for the search algorithm, but we also need to define the graph it works on. These are the abstractions I’ll use:</p>
<dl class="org-dl">
<dt>Graph</dt>
<dd>a data structure that can tell me the <code>neighbors</code> for each graph location (see <a href="../grids/graphs.html">this tutorial</a>). A <em>weighted</em> graph also gives a <code>cost</code> of moving along an edge.</dd>
<dt>Locations</dt>
<dd>a simple value (int, string, tuple, etc.) that <em>labels</em> locations in the graph. These are not necessarily locations on the map. They may include additional information such as direction, fuel, lane, or inventory, depending on the problem being solved.</dd>
<dt>Search</dt>
<dd>an algorithm that takes a graph, a starting graph location, and optionally a goal graph location, and calculates some useful information (reached, parent pointer, distance) for some or all graph locations.</dd>
<dt>Queue</dt>
<dd>a data structure used by the search algorithm to decide the order in which to process the graph locations.</dd>
</dl>
<p>In the main article, I focused on <strong>search</strong>. On this page, I’ll fill in the rest of the details to make complete working programs. Let’s start with a <strong>graph</strong>. What does a graph look like? It’s a <strong>location</strong> type along with a class with a method to get neighboring locations:</p>
<div class="org-src-container"><pre class="src src-python"><span class="variable-name">Location</span> <span class="operator">=</span> TypeVar(<span class="string">'Location'</span>)
<span class="keyword">class</span> <span class="type">Graph</span>(Protocol):
    <span class="keyword">def</span> <span class="function-name">neighbors</span>(<span class="keyword">self</span>, <span class="builtin">id</span>: Location) <span class="operator">-&gt;</span> <span class="builtin">list</span>[Location]: <span class="keyword">pass</span>
</pre></div>
<p>I’m using Python’s <a href="https://peps.python.org/pep-0526/">type hints</a><sup class="print-endnote">[1]</sup> to try to make it easier to understand which variables hold a <code>list</code>, a <code>dict</code>, a <code>Location</code>, etc. <code>Graph</code> is the <em>interface</em> that the search algorithms will want. Here’s an implementation go to with it:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">class</span> <span class="type">SimpleGraph</span>:
    <span class="keyword">def</span> <span class="function-name">__init__</span>(<span class="keyword">self</span>):
        <span class="keyword">self</span>.<span class="variable-name">edges</span>: <span class="builtin">dict</span>[<span class="type">Location</span>, <span class="builtin">list</span>[<span class="type">Location</span>]] <span class="operator">=</span> {}
    
    <span class="keyword">def</span> <span class="function-name">neighbors</span>(<span class="keyword">self</span>, <span class="builtin">id</span>: Location) <span class="operator">-&gt;</span> <span class="builtin">list</span>[Location]:
        <span class="keyword">return</span> <span class="keyword">self</span>.edges[<span class="builtin">id</span>]
</pre></div>
<p>Yes, that’s all we need! You may be asking, where’s the Node object? The answer is: I rarely use a node object. I find it simpler to use integers, strings, or tuples as the <code>Location</code> type, and then use arrays (Python lists) or hash tables (Python dicts) that use locations as an index.</p>
<p>Note that the edges are <em>directed</em>: we can have an edge from A to B without also having an edge from B to A. In simple maps, edges are bidirectional, but game maps sometimes have one-way doors or jumps off cliffs, and road maps often have one-way roads or no-left-turn restrictions. The graph search algorithms work with these directional edges, and treat bidirectional edges as two one-way edges. Let’s start with an example map with both two-way and one-way edges:</p>
<figure><svg viewBox="-5 0 32 15"><defs><marker id="arrowhead" viewBox="0 0 10 10" refX="7" refY="5" markerUnits="strokeWidth" markerWidth="4" markerHeight="3" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z"></path></marker></defs><g fill="hsl(200,50%,80%)" stroke="white" stroke-width="0.2"><rect x="1" y="3.5" width="4" height="1.5" rx="0.5"></rect><rect x="11" y="2.5" width="6" height="1.5" rx="0.5"></rect><rect x="11" y="12.5" width="10" height="1.5" rx="0.5"></rect><rect x="4" y="11.5" width="6" height="1.5" rx="0.5"></rect><rect x="8" y="8.5" width="3" height="1.5" rx="0.5"></rect><rect x="16" y="6.5" width="5" height="1.5" rx="0.5"></rect></g><g fill="hsl(30,20%,60%)" stroke="hsl(30,20%,60%)" stroke-width="0.01"><rect x="0" y="1" width="1" height="4"></rect><rect x="3" y="6" width="1" height="8"></rect><rect x="7" y="1" width="1" height="6"></rect><rect x="21" y="1" width="1" height="13"></rect><rect x="13" y="5" width="1" height="4"></rect><rect x="10" y="11" width="1" height="3"></rect><rect x="0" y="0" width="22" height="1"></rect><rect x="0" y="5" width="5" height="1"></rect><rect x="11" y="4" width="6" height="1"></rect><rect x="10" y="14" width="12" height="1"></rect><rect x="3" y="13" width="7" height="1"></rect><rect x="8" y="10" width="3" height="1"></rect><rect x="16" y="8" width="5" height="1"></rect></g><path stroke="hsl(30,30%,30%)" stroke-width="2" stroke-dasharray="0.1,0.4" d="M 10,4 l 0,4"></path><path stroke="hsl(30,30%,30%)" stroke-width="0.1" d="M 9.2,3.8 l 0,4.4 M 10.8,3.8 l 0,4.4"></path><path stroke="hsl(30,30%,30%)" stroke-width="0.1" d="M 1,5 l 4,0 M 11,4 l 6,0 M 11,14 l 10,0 M 4,13 l 6,0 M 8,10 l 3,0 M 16,8 l 5,0"></path><g fill="hsl(200,50%,40%)" transform="translate(0,-0.4)" font-family="sans-serif" font-size="1" font-weight="bold" text-anchor="middle"><text x="3" y="5">A</text><text x="7" y="13">B</text><text x="9.5" y="10">C</text><text x="14" y="4">D</text><text x="18.5" y="8">E</text><text x="16" y="14">F</text></g><g stroke="black" stroke-width="0.1" fill="none" marker-end="url(#arrowhead)"><path d="M 4.5,4.5 c 1,0 1,-1 1,6"></path><path d="M 6,12 q 0,-3.5 2.5,-3"></path><path d="M 8,9.5 q -1.5,-0 -1.5,2"></path><path d="M 8.3,8 c -0.2,-5 0,-5 3,-5"></path><path d="M 11,3.5 c -3,0 -2.5,0 -2.5,5"></path><path d="M 17,3.5 c 1,0 1,0 1,3"></path><path d="M 10.5,9.5 q 3,0 3,3"></path><path d="M 16,7.5 c -1.5,0 -1.5,0 -1.5,5"></path></g></svg></figure><p>Part of turning a map into a graph is choosing which locations to mark. Here I decided to mark each horizontal platform as a location. We can represent this example in a graph where the <code>Location</code> type is a letter A, B, C, D, E, or F.</p>
<div class="results" id="org65653e3"><figure id="orga2d84c0"><img src="implementation-example-graph.png?2025-02-09-11-16-54" alt="implementation-example-graph.png"></figure></div>
<p>For each location I need a list of which locations it leads to:</p>
<div class="org-src-container"><pre class="src src-python"><span class="variable-name">example_graph</span> <span class="operator">=</span> SimpleGraph()
example_graph.<span class="variable-name">edges</span> <span class="operator">=</span> {
    <span class="string">'A'</span>: [<span class="string">'B'</span>],
    <span class="string">'B'</span>: [<span class="string">'C'</span>],
    <span class="string">'C'</span>: [<span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'F'</span>],
    <span class="string">'D'</span>: [<span class="string">'C'</span>, <span class="string">'E'</span>],
    <span class="string">'E'</span>: [<span class="string">'F'</span>],
    <span class="string">'F'</span>: [],
}
</pre></div>
<p>Before we can use it with a search algorithm, we need to make a <strong>queue</strong>:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">import</span> collections

<span class="keyword">class</span> <span class="type">Queue</span>:
    <span class="keyword">def</span> <span class="function-name">__init__</span>(<span class="keyword">self</span>):
        <span class="keyword">self</span>.<span class="variable-name">elements</span> <span class="operator">=</span> collections.deque()
    
    <span class="keyword">def</span> <span class="function-name">empty</span>(<span class="keyword">self</span>) <span class="operator">-&gt;</span> <span class="builtin">bool</span>:
        <span class="keyword">return</span> <span class="keyword">not</span> <span class="keyword">self</span>.elements
    
    <span class="keyword">def</span> <span class="function-name">put</span>(<span class="keyword">self</span>, x: T):
        <span class="keyword">self</span>.elements.append(x)
    
    <span class="keyword">def</span> <span class="function-name">get</span>(<span class="keyword">self</span>) <span class="operator">-&gt;</span> T:
        <span class="keyword">return</span> <span class="keyword">self</span>.elements.popleft()
</pre></div>
<p>This queue class is a wrapper around the built-in <code>collections.deque</code> class. Feel free to use <code>deque</code> directly in your own code.</p>
<p>Let’s try the example graph with this queue and the breadth-first search algorithm code from the main article:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>

<span class="keyword">def</span> <span class="function-name">breadth_first_search</span>(graph: Graph, start: Location):
    <span class="comment-delimiter"># </span><span class="comment">print out what we find</span>
    <span class="variable-name">frontier</span> <span class="operator">=</span> Queue()
    frontier.put(start)
    <span class="variable-name">reached</span>: <span class="builtin">set</span>[<span class="type">Location</span>] <span class="operator">=</span> <span class="builtin">set</span>()
    reached.add(start)
    
    <span class="keyword">while</span> <span class="keyword">not</span> frontier.empty():
        <span class="variable-name">current</span>: <span class="type">Location</span> <span class="operator">=</span> frontier.get()
        <span class="builtin">print</span>(<span class="string">"  Visiting %s"</span> <span class="operator">%</span> current)
        <span class="keyword">for</span> <span class="builtin">next</span> <span class="keyword">in</span> graph.neighbors(current):
            <span class="keyword">if</span> <span class="builtin">next</span> <span class="keyword">not</span> <span class="keyword">in</span> reached:
                frontier.put(<span class="builtin">next</span>)
                reached.add(<span class="builtin">next</span>)

<span class="builtin">print</span>(<span class="string">'Reachable from A:'</span>)
breadth_first_search(example_graph, <span class="string">'A'</span>)
<span class="builtin">print</span>(<span class="string">'Reachable from E:'</span>)
breadth_first_search(example_graph, <span class="string">'E'</span>)
</pre></div>
<p>Grids can be expressed as graphs too. I’ll now define a new <strong>graph</strong> called <code>SquareGrid</code>, with <code>GridLocation</code> being a tuple <code>(x: int, y: int)</code>. In this map, the graph nodes (“states”) are the same as locations on the game map, but in many problems graph nodes are not the same as map locations. Instead of storing the edges explicitly, I’ll calculate them in the <code>neighbors</code> function. In many problems it’s better to store them explicitly.</p>
<div class="org-src-container"><pre class="src src-python"><span class="variable-name">GridLocation</span> <span class="operator">=</span> Tuple[<span class="builtin">int</span>, <span class="builtin">int</span>]

<span class="keyword">class</span> <span class="type">SquareGrid</span>:
    <span class="keyword">def</span> <span class="function-name">__init__</span>(<span class="keyword">self</span>, width: <span class="builtin">int</span>, height: <span class="builtin">int</span>):
        <span class="keyword">self</span>.<span class="variable-name">width</span> <span class="operator">=</span> width
        <span class="keyword">self</span>.<span class="variable-name">height</span> <span class="operator">=</span> height
        <span class="keyword">self</span>.<span class="variable-name">walls</span>: <span class="builtin">list</span>[<span class="type">GridLocation</span>] <span class="operator">=</span> []
    
    <span class="keyword">def</span> <span class="function-name">in_bounds</span>(<span class="keyword">self</span>, <span class="builtin">id</span>: GridLocation) <span class="operator">-&gt;</span> <span class="builtin">bool</span>:
        (<span class="variable-name">x</span>, <span class="variable-name">y</span>) <span class="operator">=</span> <span class="builtin">id</span>
        <span class="keyword">return</span> 0 <span class="operator">&lt;=</span> x <span class="operator">&lt;</span> <span class="keyword">self</span>.width <span class="keyword">and</span> 0 <span class="operator">&lt;=</span> y <span class="operator">&lt;</span> <span class="keyword">self</span>.height
    
    <span class="keyword">def</span> <span class="function-name">passable</span>(<span class="keyword">self</span>, <span class="builtin">id</span>: GridLocation) <span class="operator">-&gt;</span> <span class="builtin">bool</span>:
        <span class="keyword">return</span> <span class="builtin">id</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="keyword">self</span>.walls
    
    <span class="keyword">def</span> <span class="function-name">neighbors</span>(<span class="keyword">self</span>, <span class="builtin">id</span>: GridLocation) <span class="operator">-&gt;</span> Iterator[GridLocation]:
        (<span class="variable-name">x</span>, <span class="variable-name">y</span>) <span class="operator">=</span> <span class="builtin">id</span>
        <span class="variable-name">neighbors</span> <span class="operator">=</span> [(x<span class="operator">+</span>1, y), (x<span class="operator">-</span>1, y), (x, y<span class="operator">-</span>1), (x, y<span class="operator">+</span>1)] <span class="comment-delimiter"># </span><span class="comment">E W N S</span>
        <span class="comment-delimiter"># </span><span class="comment">see "Ugly paths" section for an explanation:</span>
        <span class="keyword">if</span> (x <span class="operator">+</span> y) <span class="operator">%</span> 2 <span class="operator">==</span> 0: neighbors.reverse() <span class="comment-delimiter"># </span><span class="comment">S N W E</span>
        <span class="variable-name">results</span> <span class="operator">=</span> <span class="builtin">filter</span>(<span class="keyword">self</span>.in_bounds, neighbors)
        <span class="variable-name">results</span> <span class="operator">=</span> <span class="builtin">filter</span>(<span class="keyword">self</span>.passable, results)
        <span class="keyword">return</span> results
</pre></div>
<p>Let’s try it out with the first grid in the main article:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>
<span class="variable-name">g</span> <span class="operator">=</span> SquareGrid(30, 15)
g.<span class="variable-name">walls</span> <span class="operator">=</span> DIAGRAM1_WALLS <span class="comment-delimiter"># </span><span class="comment">long list, [(21, 0), (21, 2), ...]</span>
draw_grid(g)
</pre></div>
<pre class="example" id="orgbcc5ff3">__________________________________________________________________________________________
 .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  . ###### .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  . ############### .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  . ############### .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>In order to reconstruct paths we need to store the location of where we came from, so I’ve renamed <code>reached</code> (True/False) to <code>came_from</code> (location):</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>

<span class="keyword">def</span> <span class="function-name">breadth_first_search</span>(graph: Graph, start: Location):
    <span class="variable-name">frontier</span> <span class="operator">=</span> Queue()
    frontier.put(start)
    <span class="variable-name">came_from</span>: <span class="builtin">dict</span>[<span class="type">Location</span>, <span class="type">Optional</span>[<span class="type">Location</span>]] <span class="operator">=</span> {}
    <span class="variable-name">came_from</span>[start] <span class="operator">=</span> <span class="constant">None</span>
    
    <span class="keyword">while</span> <span class="keyword">not</span> frontier.empty():
        <span class="variable-name">current</span>: <span class="type">Location</span> <span class="operator">=</span> frontier.get()
        <span class="keyword">for</span> <span class="builtin">next</span> <span class="keyword">in</span> graph.neighbors(current):
            <span class="keyword">if</span> <span class="builtin">next</span> <span class="keyword">not</span> <span class="keyword">in</span> came_from:
                frontier.put(<span class="builtin">next</span>)
                <span class="variable-name">came_from</span>[<span class="builtin">next</span>] <span class="operator">=</span> current
    
    <span class="keyword">return</span> came_from

<span class="variable-name">g</span> <span class="operator">=</span> SquareGrid(30, 15)
g.<span class="variable-name">walls</span> <span class="operator">=</span> DIAGRAM1_WALLS

<span class="variable-name">start</span> <span class="operator">=</span> (8, 7)
<span class="variable-name">parents</span> <span class="operator">=</span> breadth_first_search(g, start)
draw_grid(g, point_to<span class="operator">=</span>parents, start<span class="operator">=</span>start)
</pre></div>
<pre class="example" id="org6c70386">__________________________________________________________________________________________
 &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt; ###### v  v  v  v  v  v  v 
 &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; ###### &gt;  v  v  v  v  v  v 
 &gt;  &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; ###### &gt;  &gt;  v  v  v  v  v 
 &gt;  &gt;  ^ ###### v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; ###### &gt;  &gt;  &gt;  v  v  v  v 
 &gt;  ^  ^ ###### v  v  v  v  v  v  v  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt; ###### &gt;  &gt;  &gt;  v  v  v  v 
 ^  ^  ^ ###### &gt;  v  v  v  v  v  &lt;  &lt; ###### ^  ^  &lt;  &lt;  &lt;  &lt; ############### v  v  v  &lt; 
 ^  ^  ^ ###### &gt;  &gt;  v  v  v  &lt;  &lt;  &lt; ###### ^  ^  ^  &lt;  &lt;  &lt; ############### v  v  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  &gt;  A  &lt;  &lt;  &lt;  &lt; ###### ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  ^  ^  ^  &lt;  &lt;  &lt; ###### ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  v ###### &gt;  ^  ^  ^  ^  ^  &lt;  &lt; ###### ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  v  v ###### ^  ^  ^  ^  ^  ^  ^  &lt; ###### ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  &gt;  v ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  &gt;  &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt; 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>Some implementations use <em>internal storage</em>, creating a Node object to hold <code>came_from</code> and other values for each graph node. I’ve instead chosen to use <em>external storage</em>, creating a single hash table to store the <code>came_from</code> for all graph nodes. If you know your map locations have integer indices, another option is to use an array to store <code>came_from</code>.</p>
<h3 id="python-early-exit">
<span class="section-number"> 1.2 </span><span>Early Exit</span><a class="anchor" aria-hidden="true" href="#python-early-exit">#</a>
</h3>
<p>Following the code from the main article, we need to add an <em>if</em> statement to the main loop. This test is optional for Breadth First Search or Dijkstra’s Algorithm and effectively required for Greedy Best-First Search and A*:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>

<span class="keyword">def</span> <span class="function-name">breadth_first_search</span>(graph: Graph, start: Location, goal: Location):
    <span class="variable-name">frontier</span> <span class="operator">=</span> Queue()
    frontier.put(start)
    <span class="variable-name">came_from</span>: <span class="builtin">dict</span>[<span class="type">Location</span>, <span class="type">Optional</span>[<span class="type">Location</span>]] <span class="operator">=</span> {}
    <span class="variable-name">came_from</span>[start] <span class="operator">=</span> <span class="constant">None</span>
    
    <span class="keyword">while</span> <span class="keyword">not</span> frontier.empty():
        <span class="variable-name">current</span>: <span class="type">Location</span> <span class="operator">=</span> frontier.get()
        
        <span class="keyword">if</span> current <span class="operator">==</span> goal: <span class="comment-delimiter"># </span><span class="comment">early exit</span>
            <span class="keyword">break</span>
        
        <span class="keyword">for</span> <span class="builtin">next</span> <span class="keyword">in</span> graph.neighbors(current):
            <span class="keyword">if</span> <span class="builtin">next</span> <span class="keyword">not</span> <span class="keyword">in</span> came_from:
                frontier.put(<span class="builtin">next</span>)
                <span class="variable-name">came_from</span>[<span class="builtin">next</span>] <span class="operator">=</span> current
    
    <span class="keyword">return</span> came_from

<span class="variable-name">g</span> <span class="operator">=</span> SquareGrid(30, 15)
g.<span class="variable-name">walls</span> <span class="operator">=</span> DIAGRAM1_WALLS

<span class="variable-name">start</span> <span class="operator">=</span> (8, 7)
<span class="variable-name">goal</span> <span class="operator">=</span> (17, 2)
<span class="variable-name">parents</span> <span class="operator">=</span> breadth_first_search(g, start, goal)
draw_grid(g, point_to<span class="operator">=</span>parents, start<span class="operator">=</span>start, goal<span class="operator">=</span>goal)
</pre></div>
<pre class="example" id="orgc474e98">__________________________________________________________________________________________
 .  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  v  v  &lt;  .  .  .  . ###### .  .  .  .  .  .  . 
 &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  .  .  . ###### .  .  .  .  .  .  . 
 &gt;  &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  Z  .  .  . ###### .  .  .  .  .  .  . 
 &gt;  &gt;  ^ ###### v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  .  . ###### .  .  .  .  .  .  . 
 .  ^  ^ ###### v  v  v  v  v  v  v  &lt; ###### ^  &lt;  &lt;  .  .  . ###### .  .  .  .  .  .  . 
 .  .  ^ ###### &gt;  v  v  v  v  v  &lt;  &lt; ###### ^  ^  .  .  .  . ############### .  .  .  . 
 .  .  . ###### &gt;  &gt;  v  v  v  &lt;  &lt;  &lt; ###### ^  .  .  .  .  . ############### .  .  .  . 
 .  .  . ###### &gt;  &gt;  &gt;  A  &lt;  &lt;  &lt;  &lt; ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### &gt;  &gt;  ^  ^  ^  &lt;  &lt;  &lt; ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  v ###### &gt;  ^  ^  ^  ^  ^  &lt;  &lt; ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  v  v ###### ^  ^  ^  ^  ^  ^  ^  &lt; ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 &gt;  &gt;  v ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 &gt;  &gt;  &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 &gt;  &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>You can see that the algorithm stops when it finds the goal <code>Z</code>. Early exit is also useful for <a href="../early-exit/">problems other than standard pathfinding</a>.</p>
<h3 id="python-dijkstra">
<span class="section-number"> 1.3 </span><span>Dijkstra’s Algorithm</span><a class="anchor" aria-hidden="true" href="#python-dijkstra">#</a>
</h3>
<p>This is what adds complexity to graph search, because we’re going to start processing locations in a better order than “first in, first out”. What do we need to change?</p>
<ol class="org-ol">
<li>The <em>graph</em> needs to know cost of movement.</li>
<li>The <em>queue</em> needs to return nodes in a different order.</li>
<li>The <em>search</em> needs to keep track of these costs from the graph and give them to the queue.</li>
</ol>
<h4 id="python-graph-with-weights">
<span><span class="section-number-4">1.3.1.</span> Graph with weights</span><a class="anchor" aria-hidden="true" href="#python-graph-with-weights">#</a>
</h4>
<p>A regular graph tells me the <code>neighbors</code> of each node. A <em>weighted</em> graph also tells me the cost of moving along each edge. I’m going to add a <code>cost(from_node, to_node)</code> function that tells us the cost of moving from location <code>from_node</code> to its neighbor <code>to_node</code>. Here’s the interface:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">class</span> <span class="type">WeightedGraph</span>(Graph):
    <span class="keyword">def</span> <span class="function-name">cost</span>(<span class="keyword">self</span>, from_id: Location, to_id: Location) <span class="operator">-&gt;</span> <span class="builtin">float</span>: <span class="keyword">pass</span>
</pre></div>
<p>Let’s implement the interface with a grid that uses grid locations and stores the weights in a dict:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">class</span> <span class="type">GridWithWeights</span>(SquareGrid):
    <span class="keyword">def</span> <span class="function-name">__init__</span>(<span class="keyword">self</span>, width: <span class="builtin">int</span>, height: <span class="builtin">int</span>):
        <span class="builtin">super</span>().__init__(width, height)
        <span class="keyword">self</span>.<span class="variable-name">weights</span>: <span class="builtin">dict</span>[<span class="type">GridLocation</span>, <span class="builtin">float</span>] <span class="operator">=</span> {}
    
    <span class="keyword">def</span> <span class="function-name">cost</span>(<span class="keyword">self</span>, from_node: GridLocation, to_node: GridLocation) <span class="operator">-&gt;</span> <span class="builtin">float</span>:
        <span class="keyword">return</span> <span class="keyword">self</span>.weights.get(to_node, 1)
</pre></div>
<p>In this forest map I chose to make movement depend only on <code>to_node</code>, but <a href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html">there are other types of movement that use both nodes</a><sup class="print-endnote">[2]</sup>. An alternate implementation would be to include the movement costs in the value returned by the <code>neighbors</code> function.</p>
<h4 id="python-queue-with-priorities">
<span><span class="section-number-4">1.3.2.</span> Queue with priorities</span><a class="anchor" aria-hidden="true" href="#python-queue-with-priorities">#</a>
</h4>
<p>A priority queue associates with each item a number called a “priority”. When returning an item, it picks the one with the lowest number.</p>
<dl class="org-dl">
<dt>insert</dt>
<dd>Add item to queue</dd>
<dt>remove</dt>
<dd>Remove item with the lowest number</dd>
<dt>reprioritize</dt>
<dd>(optional) Change an existing item’s priority to a lower number</dd>
</dl>
<p>Here’s a reasonably fast priority queue that uses <em>binary heaps</em>, but does not support reprioritize. To get the right ordering, we’ll use tuples (priority, item). When an element is inserted that is already in the queue, we’ll have a duplicate; I’ll explain why that’s ok in the Optimization section.</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">import</span> heapq

<span class="keyword">class</span> <span class="type">PriorityQueue</span>:
    <span class="keyword">def</span> <span class="function-name">__init__</span>(<span class="keyword">self</span>):
        <span class="keyword">self</span>.<span class="variable-name">elements</span>: <span class="builtin">list</span>[<span class="builtin">tuple</span>[<span class="builtin">float</span>, <span class="type">T</span>]] <span class="operator">=</span> []
    
    <span class="keyword">def</span> <span class="function-name">empty</span>(<span class="keyword">self</span>) <span class="operator">-&gt;</span> <span class="builtin">bool</span>:
        <span class="keyword">return</span> <span class="keyword">not</span> <span class="keyword">self</span>.elements
    
    <span class="keyword">def</span> <span class="function-name">put</span>(<span class="keyword">self</span>, item: T, priority: <span class="builtin">float</span>):
        heapq.heappush(<span class="keyword">self</span>.elements, (priority, item))
    
    <span class="keyword">def</span> <span class="function-name">get</span>(<span class="keyword">self</span>) <span class="operator">-&gt;</span> T:
        <span class="keyword">return</span> heapq.heappop(<span class="keyword">self</span>.elements)[1]
</pre></div>
<p>Note that Python now has a <code>queue.PriorityQueue</code> class you can use directly instead of this wrapper. The API is slightly different.</p>
<h4 id="python-search">
<span><span class="section-number-4">1.3.3.</span> Search</span><a class="anchor" aria-hidden="true" href="#python-search">#</a>
</h4>
<p>Here’s a tricky bit about the implementation: once we add movement costs it’s possible to visit a location again, with a better <code>cost_so_far</code>. That means the line <code>if next not in came_from</code> won’t work. Instead, have to check if the cost has gone down since the last time we reached. (In the original version of the article I wasn’t checking this, but my code worked anyway; <a href="../posts/reprioritize.html">I wrote some notes about that bug</a>.)</p>
<p>This forest map is from <a href="./introduction.html#dijkstra">the main page</a>.</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">def</span> <span class="function-name">dijkstra_search</span>(graph: WeightedGraph, start: Location, goal: Location):
    <span class="variable-name">frontier</span> <span class="operator">=</span> PriorityQueue()
    frontier.put(start, 0)
    <span class="variable-name">came_from</span>: <span class="builtin">dict</span>[<span class="type">Location</span>, <span class="type">Optional</span>[<span class="type">Location</span>]] <span class="operator">=</span> {}
    <span class="variable-name">cost_so_far</span>: <span class="builtin">dict</span>[<span class="type">Location</span>, <span class="builtin">float</span>] <span class="operator">=</span> {}
    <span class="variable-name">came_from</span>[start] <span class="operator">=</span> <span class="constant">None</span>
    <span class="variable-name">cost_so_far</span>[start] <span class="operator">=</span> 0
    
    <span class="keyword">while</span> <span class="keyword">not</span> frontier.empty():
        <span class="variable-name">current</span>: <span class="type">Location</span> <span class="operator">=</span> frontier.get()
        
        <span class="keyword">if</span> current <span class="operator">==</span> goal:
            <span class="keyword">break</span>
        
        <span class="keyword">for</span> <span class="builtin">next</span> <span class="keyword">in</span> graph.neighbors(current):
            <span class="variable-name">new_cost</span> <span class="operator">=</span> cost_so_far[current] <span class="operator">+</span> graph.cost(current, <span class="builtin">next</span>)
            <span class="keyword">if</span> <span class="builtin">next</span> <span class="keyword">not</span> <span class="keyword">in</span> cost_so_far <span class="keyword">or</span> new_cost <span class="operator">&lt;</span> cost_so_far[<span class="builtin">next</span>]:
                <span class="variable-name">cost_so_far</span>[<span class="builtin">next</span>] <span class="operator">=</span> new_cost
                <span class="variable-name">priority</span> <span class="operator">=</span> new_cost
                frontier.put(<span class="builtin">next</span>, priority)
                <span class="variable-name">came_from</span>[<span class="builtin">next</span>] <span class="operator">=</span> current
    
    <span class="keyword">return</span> came_from, cost_so_far
</pre></div>
<p>Finally, after searching I need to build the path:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">def</span> <span class="function-name">reconstruct_path</span>(came_from: <span class="builtin">dict</span>[Location, Location],
                     start: Location, goal: Location) <span class="operator">-&gt;</span> <span class="builtin">list</span>[Location]:

    <span class="variable-name">current</span>: <span class="type">Location</span> <span class="operator">=</span> goal
    <span class="variable-name">path</span>: <span class="builtin">list</span>[<span class="type">Location</span>] <span class="operator">=</span> []
    <span class="keyword">if</span> goal <span class="keyword">not</span> <span class="keyword">in</span> came_from: <span class="comment-delimiter"># </span><span class="comment">no path was found</span>
        <span class="keyword">return</span> []
    <span class="keyword">while</span> current <span class="operator">!=</span> start:
        path.append(current)
        <span class="variable-name">current</span> <span class="operator">=</span> came_from[current]
    path.append(start) <span class="comment-delimiter"># </span><span class="comment">optional</span>
    path.reverse() <span class="comment-delimiter"># </span><span class="comment">optional</span>
    <span class="keyword">return</span> path
</pre></div>
<p>Although paths are best thought of as a sequence of edges, it’s convenient to store them as a sequence of nodes. To build the path, start at the end and follow the <code>came_from</code> map, which points to the previous node. When we reach start, we’re done. It is the <strong>backwards</strong> path, so call <code>reverse()</code> at the end of <code>reconstruct_path</code> if you need it to be stored forwards. Sometimes it’s actually more convenient to store it backwards. Sometimes it’s useful to also store the start node in the list.</p>
<p>Let’s try it out:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>
<span class="variable-name">start</span>, <span class="variable-name">goal</span> <span class="operator">=</span> (1, 4), (8, 3)
<span class="variable-name">came_from</span>, <span class="variable-name">cost_so_far</span> <span class="operator">=</span> dijkstra_search(diagram4, start, goal)
draw_grid(diagram4, point_to<span class="operator">=</span>came_from, start<span class="operator">=</span>start, goal<span class="operator">=</span>goal)
<span class="builtin">print</span>()
draw_grid(diagram4, path<span class="operator">=</span>reconstruct_path(came_from, start<span class="operator">=</span>start, goal<span class="operator">=</span>goal))
</pre></div>
<pre class="example" id="org58e5eb1">______________________________
 v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  &lt;  &lt;  &lt;  ^  ^  &lt;  &lt;  &lt; 
 v  v  &lt;  &lt;  &lt;  &lt;  ^  ^  &lt;  &lt; 
 v  v  &lt;  &lt;  &lt;  &lt;  &lt;  ^  Z  . 
 &gt;  A  &lt;  &lt;  &lt;  &lt;  .  .  .  . 
 ^  ^  &lt;  &lt;  &lt;  &lt;  .  .  .  . 
 ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  .  .  . 
 ^ ######### ^  &lt;  v  v  .  . 
 ^ ######### v  v  v  &lt;  &lt;  . 
 ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

______________________________
 .  @  @  @  @  @  @  .  .  . 
 .  @  .  .  .  .  @  @  .  . 
 .  @  .  .  .  .  .  @  @  . 
 .  @  .  .  .  .  .  .  @  . 
 .  @  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
 . ######### .  .  .  .  .  . 
 . ######### .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>The first output shows the vector field; the second shows the path.</p>
<p>Why is the path going up and over? Remember that this is the forest example from the main page, where the middle of the map has a big forest that’s slow to move through. The shortest path goes around the forest, not through it.</p>
<p>The line <code>if next not in cost_so_far or new_cost &lt; cost_so_far[next]</code> could be simplified to <code>if new_cost &lt; cost_so_far.get(next, Infinity)</code> but I didn’t want to explain Python’s <code>get()</code> in the main article so I left it as is. Another approach would be to use <code>collections.defaultdict</code> defaulting to infinity.</p>
<h4 id="python-no-path">
<span><span class="section-number-4">1.3.4.</span> No path</span><a class="anchor" aria-hidden="true" href="#python-no-path">#</a>
</h4>
<p>There’s a tricky case — what if there’s no path? Let’s try a wall that completely blocks the left and right sides from each other.</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>
<span class="variable-name">start</span>, <span class="variable-name">goal</span> <span class="operator">=</span> (1, 4), (8, 3)
<span class="variable-name">came_from</span>, <span class="variable-name">cost_so_far</span> <span class="operator">=</span> dijkstra_search(diagram_nopath, start, goal)
draw_grid(diagram_nopath, point_to<span class="operator">=</span>came_from, start<span class="operator">=</span>start, goal<span class="operator">=</span>goal)
<span class="comment-delimiter"># </span><span class="comment">reconstruct_path(came_from, start=start, goal=goal) will be []</span>
</pre></div>
<pre class="example" id="orgdb591a3">______________________________
 v  v  &lt;  &lt;  &lt; ### .  .  .  . 
 v  v  &lt;  &lt;  &lt; ### .  .  .  . 
 v  v  &lt;  &lt;  &lt; ### .  .  .  . 
 v  v  &lt;  &lt;  &lt; ### .  .  Z  . 
 &gt;  A  &lt;  &lt;  &lt; ### .  .  .  . 
 ^  ^  &lt;  &lt;  &lt; ### .  .  .  . 
 ^  ^  &lt;  &lt;  &lt; ### .  .  .  . 
 ^  ^  &lt;  &lt;  &lt; ### .  .  .  . 
 ^  ^  &lt;  &lt;  &lt; ### .  .  .  . 
 ^  ^  &lt;  &lt;  &lt; ### .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>The search algorithm will try to explore as much as it can but it just can’t get from <kbd>A</kbd> to <kbd>Z</kbd>. We can detect this in <code>reconstruct_path</code> because <code>goal</code> will not be in the <code>came_from</code> map. It can still be <em>slow</em> though, as the search algorithm has to explore every nook and cranny before realizing there’s no path. If you can, pre-process the map with <a href="https://en.wikipedia.org/wiki/Connected-component_labeling">connected component labeling</a><sup class="print-endnote">[3]</sup> to determine whether there’s a path <em>before</em> running graph search.</p>
<h4 id="python-distance-field">
<span><span class="section-number-4">1.3.5.</span> Distance fields</span><a class="anchor" aria-hidden="true" href="#python-distance-field">#</a>
</h4>
<p>Collecting distances instead of directions gives us a <em>distance field</em>. Here’s an example of computing the distance from the start location <kbd>A</kbd>, with no goal:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>
<span class="variable-name">start</span>, <span class="variable-name">goal</span> <span class="operator">=</span> (1, 4), <span class="constant">None</span>
<span class="variable-name">came_from</span>, <span class="variable-name">cost_so_far</span> <span class="operator">=</span> dijkstra_search(diagram4, start, goal)
draw_grid(diagram4, number<span class="operator">=</span>cost_so_far, start<span class="operator">=</span>start)
</pre></div>
<pre class="example" id="org3a62263">______________________________
 5  4  5  6  7  8  9  10 11 12
 4  3  4  5  10 13 10 11 12 13
 3  2  3  4  9  14 15 12 13 14
 2  1  2  3  8  13 18 17 14 15
 1  A  1  6  11 16 21 20 15 16
 2  1  2  7  12 17 22 21 16 17
 3  2  3  4  9  14 19 16 17 18
 4 ######### 14 19 18 15 16 17
 5 ######### 15 16 13 14 15 16
 6  7  8  9  10 11 12 13 14 15
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>Distance fields be useful for some <a href="../distance-to-any/">variants of pathfinding</a>. For these I’ll often run the search algorithm <em>without</em> early exit, or with <a href="../early-exit/">a different type of early exit</a>.</p>
<h3 id="python-astar">
<span class="section-number"> 1.4 </span><span>A* Search</span><a class="anchor" aria-hidden="true" href="#python-astar">#</a>
</h3>
<p>A* is almost exactly like Dijkstra’s Algorithm, except we add in a heuristic. Note that the code for the algorithm <em>isn’t specific to grids</em>. Knowledge about grids is in the graph class (<code>GridWithWeights</code>), the locations, and in the <code>heuristic</code> function. Replace those three and you can use the A* algorithm code with any other graph structure.</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">def</span> <span class="function-name">heuristic</span>(a: GridLocation, b: GridLocation) <span class="operator">-&gt;</span> <span class="builtin">float</span>:
    (<span class="variable-name">x1</span>, <span class="variable-name">y1</span>) <span class="operator">=</span> a
    (<span class="variable-name">x2</span>, <span class="variable-name">y2</span>) <span class="operator">=</span> b
    <span class="keyword">return</span> <span class="builtin">abs</span>(x1 <span class="operator">-</span> x2) <span class="operator">+</span> <span class="builtin">abs</span>(y1 <span class="operator">-</span> y2)

<span class="keyword">def</span> <span class="function-name">a_star_search</span>(graph: WeightedGraph, start: Location, goal: Location):
    <span class="variable-name">frontier</span> <span class="operator">=</span> PriorityQueue()
    frontier.put(start, 0)
    <span class="variable-name">came_from</span>: <span class="builtin">dict</span>[<span class="type">Location</span>, <span class="type">Optional</span>[<span class="type">Location</span>]] <span class="operator">=</span> {}
    <span class="variable-name">cost_so_far</span>: <span class="builtin">dict</span>[<span class="type">Location</span>, <span class="builtin">float</span>] <span class="operator">=</span> {}
    <span class="variable-name">came_from</span>[start] <span class="operator">=</span> <span class="constant">None</span>
    <span class="variable-name">cost_so_far</span>[start] <span class="operator">=</span> 0
    
    <span class="keyword">while</span> <span class="keyword">not</span> frontier.empty():
        <span class="variable-name">current</span>: <span class="type">Location</span> <span class="operator">=</span> frontier.get()
        
        <span class="keyword">if</span> current <span class="operator">==</span> goal:
            <span class="keyword">break</span>
        
        <span class="keyword">for</span> <span class="builtin">next</span> <span class="keyword">in</span> graph.neighbors(current):
            <span class="variable-name">new_cost</span> <span class="operator">=</span> cost_so_far[current] <span class="operator">+</span> graph.cost(current, <span class="builtin">next</span>)
            <span class="keyword">if</span> <span class="builtin">next</span> <span class="keyword">not</span> <span class="keyword">in</span> cost_so_far <span class="keyword">or</span> new_cost <span class="operator">&lt;</span> cost_so_far[<span class="builtin">next</span>]:
                <span class="variable-name">cost_so_far</span>[<span class="builtin">next</span>] <span class="operator">=</span> new_cost
                <span class="variable-name">priority</span> <span class="operator">=</span> new_cost <span class="operator">+</span> heuristic(<span class="builtin">next</span>, goal)
                frontier.put(<span class="builtin">next</span>, priority)
                <span class="variable-name">came_from</span>[<span class="builtin">next</span>] <span class="operator">=</span> current
    
    <span class="keyword">return</span> came_from, cost_so_far
</pre></div>
<p>Let’s try it out:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>
<span class="variable-name">start</span>, <span class="variable-name">goal</span> <span class="operator">=</span> (1, 4), (8, 3)
<span class="variable-name">came_from</span>, <span class="variable-name">cost_so_far</span> <span class="operator">=</span> a_star_search(diagram4, start, goal)
draw_grid(diagram4, point_to<span class="operator">=</span>came_from, start<span class="operator">=</span>start, goal<span class="operator">=</span>goal)
<span class="builtin">print</span>()
draw_grid(diagram4, path<span class="operator">=</span>reconstruct_path(came_from, start<span class="operator">=</span>start, goal<span class="operator">=</span>goal))
</pre></div>
<pre class="example" id="orga55251a">______________________________
 v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  v  v  &lt;  ^  ^  &lt;  &lt;  &lt; 
 v  v  v  v  &lt;  &lt;  ^  ^  &lt;  &lt; 
 &gt;  v  &lt;  &lt;  &lt;  &lt;  .  ^  Z  . 
 &gt;  A  &lt;  &lt;  &lt;  .  .  .  .  . 
 ^  ^  ^  &lt;  &lt;  .  .  .  .  . 
 ^  ^  ^  &lt;  &lt;  .  .  .  .  . 
 ^ ######### .  .  .  .  .  . 
 . ######### .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

______________________________
 .  .  .  @  @  @  @  .  .  . 
 .  .  .  @  .  .  @  @  .  . 
 .  .  .  @  .  .  .  @  @  . 
 .  @  @  @  .  .  .  .  @  . 
 .  @  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
 . ######### .  .  .  .  .  . 
 . ######### .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>Here are the distances it calculated:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>
<span class="variable-name">start</span>, <span class="variable-name">goal</span> <span class="operator">=</span> (1, 4), (8, 3)
<span class="variable-name">came_from</span>, <span class="variable-name">cost_so_far</span> <span class="operator">=</span> a_star_search(diagram4, start, goal)
draw_grid(diagram4, number<span class="operator">=</span>cost_so_far, start<span class="operator">=</span>start, goal<span class="operator">=</span>goal)
</pre></div>
<pre class="example" id="orgfb62e65">______________________________
 5  4  5  6  7  8  9  10 11 12
 4  3  4  5  10 13 10 11 12 13
 3  2  3  4  9  14 15 12 13 14
 2  1  2  3  8  13 .  17 Z  . 
 1  A  1  6  11 .  .  .  .  . 
 2  1  2  7  12 .  .  .  .  . 
 3  2  3  4  9  .  .  .  .  . 
 4 ######### .  .  .  .  .  . 
 . ######### .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>And that’s it! We’ve implemented graphs, grids, Breadth First Search, Dijkstra’s Algorithm, and A*.</p>
<h4 id="python-straighter-paths">
<span><span class="section-number-4">1.4.1.</span> Straighter paths</span><a class="anchor" aria-hidden="true" href="#python-straighter-paths">#</a>
</h4>
<p>If you implement this code in your own project you might find that some of the paths aren’t as “straight” as you’d like. <strong>This is normal</strong>. When using <em>grids</em>, especially grids where every step has the same movement cost, you end up with <strong>ties</strong>: many paths have exactly the same cost. A* ends up picking one of the many short paths, and often <strong>it won’t look good to you</strong>. I list <a href="#troubleshooting-ugly-path">some solutions</a> in a later section.</p></section><section><h2 id="cpp">
<span class="section-number"> 2  </span><span><a href="#cpp"> C++ Implementation</a></span><a class="anchor" href="#cpp">#</a>
</h2>
<p>Note: some of the sample code needs to include <a href="./implementation.cpp">redblobgames/pathfinding/a-star/implementation.cpp</a> to run. I am using <strong>C++14</strong> for this code so some of it will need to be changed if you use an older version of the C++ standard.</p>
<p><em>The code here is meant for the tutorial and is not production-quality</em>; there’s a section at the end with tips on making it better.</p>
<h3 id="cpp-breadth-first">
<span class="section-number"> 2.1 </span><span>Breadth First Search</span><a class="anchor" aria-hidden="true" href="#cpp-breadth-first">#</a>
</h3>
<p>Let’s implement Breadth First Search in C++. These are the components we need:</p>
<dl class="org-dl">
<dt>Graph</dt>
<dd>a data structure that can tell me the <code>neighbors</code> for each graph location (see <a href="../grids/graphs.html">this tutorial</a>). A <em>weighted</em> graph can also tell me the <code>cost</code> of moving along an edge.</dd>
<dt>Locations</dt>
<dd>a simple value (int, string, tuple, etc.) that <em>labels</em> locations in the graph. These are not necessarily locations on the map. They may include additional information such as direction, fuel, lane, or inventory, depending on the problem being solved.</dd>
<dt>Search</dt>
<dd>an algorithm that takes a graph, a starting graph location, and optionally a goal graph location, and calculates some useful information (reached, parent pointer, distance) for some or all graph locations.</dd>
<dt>Queue</dt>
<dd>a data structure used by the search algorithm to decide the order in which to process the graph locations.</dd>
</dl>
<p>In the main article, I focused on <strong>search</strong>. On this page, I’ll fill in the rest of the details to make complete working programs. Let’s start with a <strong>graph</strong> where the locations are <code>char</code>:</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="keyword">struct</span> <span class="type">SimpleGraph</span> {
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">char</span>, <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">char</span>&gt; &gt; <span class="variable-name">edges</span>;

  <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">char</span>&gt; <span class="function-name">neighbors</span>(<span class="type">char</span> <span class="variable-name">id</span>) {
    <span class="keyword">return</span> edges[id];
  }
};
</pre></div>
<p>Note that the edges are <em>directed</em>: we can have an edge from A to B without also having an edge from B to A. In simple maps, edges are bidirectional, but game maps sometimes have one-way doors or jumps off cliffs, and road maps often have one-way roads or no-left-turn restrictions. The graph search algorithms work with these directional edges, and treat bidirectional edges as two one-way edges. Let’s start with an example map with both two-way and one-way edges:</p>
<figure><svg viewBox="-5 0 32 15"><defs><marker id="arrowhead" viewBox="0 0 10 10" refX="7" refY="5" markerUnits="strokeWidth" markerWidth="4" markerHeight="3" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z"></path></marker></defs><g fill="hsl(200,50%,80%)" stroke="white" stroke-width="0.2"><rect x="1" y="3.5" width="4" height="1.5" rx="0.5"></rect><rect x="11" y="2.5" width="6" height="1.5" rx="0.5"></rect><rect x="11" y="12.5" width="10" height="1.5" rx="0.5"></rect><rect x="4" y="11.5" width="6" height="1.5" rx="0.5"></rect><rect x="8" y="8.5" width="3" height="1.5" rx="0.5"></rect><rect x="16" y="6.5" width="5" height="1.5" rx="0.5"></rect></g><g fill="hsl(30,20%,60%)" stroke="hsl(30,20%,60%)" stroke-width="0.01"><rect x="0" y="1" width="1" height="4"></rect><rect x="3" y="6" width="1" height="8"></rect><rect x="7" y="1" width="1" height="6"></rect><rect x="21" y="1" width="1" height="13"></rect><rect x="13" y="5" width="1" height="4"></rect><rect x="10" y="11" width="1" height="3"></rect><rect x="0" y="0" width="22" height="1"></rect><rect x="0" y="5" width="5" height="1"></rect><rect x="11" y="4" width="6" height="1"></rect><rect x="10" y="14" width="12" height="1"></rect><rect x="3" y="13" width="7" height="1"></rect><rect x="8" y="10" width="3" height="1"></rect><rect x="16" y="8" width="5" height="1"></rect></g><path stroke="hsl(30,30%,30%)" stroke-width="2" stroke-dasharray="0.1,0.4" d="M 10,4 l 0,4"></path><path stroke="hsl(30,30%,30%)" stroke-width="0.1" d="M 9.2,3.8 l 0,4.4 M 10.8,3.8 l 0,4.4"></path><path stroke="hsl(30,30%,30%)" stroke-width="0.1" d="M 1,5 l 4,0 M 11,4 l 6,0 M 11,14 l 10,0 M 4,13 l 6,0 M 8,10 l 3,0 M 16,8 l 5,0"></path><g fill="hsl(200,50%,40%)" transform="translate(0,-0.4)" font-family="sans-serif" font-size="1" font-weight="bold" text-anchor="middle"><text x="3" y="5">A</text><text x="7" y="13">B</text><text x="9.5" y="10">C</text><text x="14" y="4">D</text><text x="18.5" y="8">E</text><text x="16" y="14">F</text></g><g stroke="black" stroke-width="0.1" fill="none" marker-end="url(#arrowhead)"><path d="M 4.5,4.5 c 1,0 1,-1 1,6"></path><path d="M 6,12 q 0,-3.5 2.5,-3"></path><path d="M 8,9.5 q -1.5,-0 -1.5,2"></path><path d="M 8.3,8 c -0.2,-5 0,-5 3,-5"></path><path d="M 11,3.5 c -3,0 -2.5,0 -2.5,5"></path><path d="M 17,3.5 c 1,0 1,0 1,3"></path><path d="M 10.5,9.5 q 3,0 3,3"></path><path d="M 16,7.5 c -1.5,0 -1.5,0 -1.5,5"></path></g></svg></figure><p>Part of turning a map into a graph is choosing which locations to mark. Here I decided to mark each horizontal platform as a location. We can represent this example in a graph where the <code>Location</code> type is a letter A, B, C, D, E, or F.</p>
<figure id="orge435cb8"><img src="implementation-example-graph.png?2025-02-09-11-16-54" alt="implementation-example-graph.png"></figure><div class="org-src-container"><pre class="src src-cpp"><span class="type">SimpleGraph</span> <span class="variable-name">example_graph</span> {{
    {<span class="string">'A'</span>, {<span class="string">'B'</span>}},
    {<span class="string">'B'</span>, {<span class="string">'C'</span>}},
    {<span class="string">'C'</span>, {<span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'F'</span>}},
    {<span class="string">'D'</span>, {<span class="string">'C'</span>, <span class="string">'E'</span>}},
    {<span class="string">'E'</span>, {<span class="string">'F'</span>}},
    {<span class="string">'F'</span>, {}},
  }};
</pre></div>
<p>The C++ standard library already includes a queue class. We now have a graph (<code>SimpleGraph</code>), locations (<code>char</code>), and a queue (<code>std::queue</code>). Now we can try Breadth First Search:</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="type">void</span> <span class="function-name">breadth_first_search</span>(<span class="type">SimpleGraph</span> <span class="variable-name">graph</span>, <span class="type">char</span> <span class="variable-name">start</span>) {
  <span class="constant">std</span>::<span class="type">queue</span>&lt;<span class="type">char</span>&gt; <span class="variable-name">frontier</span>;
  frontier.push(start);

  <span class="constant">std</span>::<span class="type">unordered_set</span>&lt;<span class="type">char</span>&gt; <span class="variable-name">reached</span>;
  reached.insert(start);

  <span class="keyword">while</span> (<span class="negation-char">!</span>frontier.empty()) {
    <span class="type">char</span> <span class="variable-name">current</span> = frontier.front();
    frontier.pop();

    <span class="constant">std</span>::cout &lt;&lt; <span class="string">"  Visiting "</span> &lt;&lt; current &lt;&lt; <span class="string">'\n'</span>;
    <span class="keyword">for</span> (<span class="type">char</span> <span class="variable-name">next</span> : graph.neighbors(current)) {
      <span class="keyword">if</span> (reached.find(next) == reached.end()) {
        frontier.push(next);
        reached.insert(next);
      }
    }
  }
}


<span class="type">int</span> <span class="function-name">main</span>() {
  <span class="constant">std</span>::cout &lt;&lt; <span class="string">"Reachable from A:\n"</span>;
  breadth_first_search(example_graph, <span class="string">'A'</span>);
  <span class="constant">std</span>::cout &lt;&lt; <span class="string">"Reachable from E:\n"</span>;
  breadth_first_search(example_graph, <span class="string">'E'</span>);
}
</pre></div>
<pre class="example" id="org23bd4a5">Reachable from A:
  Visiting A
  Visiting B
  Visiting C
  Visiting D
  Visiting F
  Visiting E
Reachable from E:
  Visiting E
  Visiting F
</pre>
<p>Grids can be expressed as graphs too. I’ll now define a new <strong>graph</strong> called <code>SquareGrid</code>, with <strong>locations</strong> structs with two ints. In this map, the locations (“states”) in the graph are the same as locations on the game map, but in many problems graph locations are not the same as map locations. Instead of storing the edges explicitly, I’ll calculate them in the <code>neighbors</code> function. In many problems it’s better to store them explicitly.</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="keyword">struct</span> <span class="type">GridLocation</span> {
  <span class="type">int</span> <span class="variable-name">x</span>, <span class="variable-name">y</span>;
};

<span class="keyword">namespace</span> <span class="constant">std</span> {
<span class="comment-delimiter">/* </span><span class="comment">implement hash function so we can put GridLocation into an unordered_set</span><span class="comment-delimiter"> */</span>
<span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="type">hash</span>&lt;<span class="type">GridLocation</span>&gt; {
  <span class="constant">std</span>::<span class="type">size_t</span> <span class="keyword">operator</span><span class="function-name">()</span>(<span class="keyword">const</span> <span class="type">GridLocation</span>&amp; <span class="variable-name">id</span>) <span class="keyword">const</span> <span class="keyword">noexcept</span> {
    <span class="comment-delimiter">// </span><span class="comment">I wish built-in std::hash worked on pair and tuple</span>
    <span class="keyword">return</span> <span class="constant">std</span>::hash&lt;<span class="type">int</span>&gt;()(id.x ^ (id.y &lt;&lt; 16));
  }
};
}


<span class="keyword">struct</span> <span class="type">SquareGrid</span> {
  <span class="keyword">static</span> <span class="constant">std</span>::<span class="type">array</span>&lt;<span class="type">GridLocation</span>, 4&gt; <span class="variable-name">DIRS</span>;

  <span class="type">int</span> <span class="variable-name">width</span>, <span class="variable-name">height</span>;
  <span class="constant">std</span>::<span class="type">unordered_set</span>&lt;<span class="type">GridLocation</span>&gt; <span class="variable-name">walls</span>;

  <span class="function-name">SquareGrid</span>(<span class="type">int</span> <span class="variable-name">width_</span>, <span class="type">int</span> <span class="variable-name">height_</span>)
     : width(width_), height(height_) {}

  <span class="type">bool</span> <span class="function-name">in_bounds</span>(<span class="type">GridLocation</span> <span class="variable-name">id</span>) <span class="keyword">const</span> {
    <span class="keyword">return</span> 0 &lt;= id.x &amp;&amp; id.x &lt; width
        &amp;&amp; 0 &lt;= id.y &amp;&amp; id.y &lt; height;
  }

  <span class="type">bool</span> <span class="function-name">passable</span>(<span class="type">GridLocation</span> <span class="variable-name">id</span>) <span class="keyword">const</span> {
    <span class="keyword">return</span> walls.find(id) == walls.end();
  }

  <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">GridLocation</span>&gt; <span class="function-name">neighbors</span>(<span class="type">GridLocation</span> <span class="variable-name">id</span>) <span class="keyword">const</span> {
    <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">GridLocation</span>&gt; <span class="variable-name">results</span>;

    <span class="keyword">for</span> (<span class="type">GridLocation</span> <span class="type">dir</span> : DIRS) {
      <span class="type">GridLocation</span> <span class="variable-name">next</span>{id.x + dir.x, id.y + dir.y};
      <span class="keyword">if</span> (in_bounds(next) &amp;&amp; passable(next)) {
        results.push_back(next);
      }
    }

    <span class="keyword">if</span> ((id.x + id.y) % 2 == 0) {
      <span class="comment-delimiter">// </span><span class="comment">see "Ugly paths" section for an explanation:</span>
      <span class="constant">std</span>::reverse(results.begin(), results.end());
    }

    <span class="keyword">return</span> results;
  }
};

<span class="constant">std</span>::<span class="type">array</span>&lt;<span class="type">GridLocation</span>, 4&gt; <span class="constant">SquareGrid</span>::<span class="variable-name">DIRS</span> = {
  <span class="comment-delimiter">/* </span><span class="comment">East, West, North, South</span><span class="comment-delimiter"> */</span>
  GridLocation{1, 0}, GridLocation{-1, 0},
  GridLocation{0, -1}, GridLocation{0, 1}
};
</pre></div>
<p>In the helper file <code>implementation.cpp</code> I defined a function to make grids:</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="type">int</span> <span class="function-name">main</span>() {
  <span class="type">SquareGrid</span> <span class="variable-name">grid</span> = make_diagram1();
  draw_grid(grid);
}
</pre></div>
<pre class="example" id="orgbc160f2">__________________________________________________________________________________________
 .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  . ###### .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  . ############### .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  . ############### .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>Let’s try Breadth First Search again, keeping track of <code>came_from</code>:</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">Location</span>, <span class="keyword">typename</span> <span class="type">Graph</span>&gt;
<span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt;
<span class="function-name">breadth_first_search</span>(<span class="type">Graph</span> <span class="variable-name">graph</span>, <span class="type">Location</span> <span class="variable-name">start</span>) {
  <span class="constant">std</span>::<span class="type">queue</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">frontier</span>;
  frontier.push(start);

  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt; <span class="variable-name">came_from</span>;
  came_from[start] = start;

  <span class="keyword">while</span> (<span class="negation-char">!</span>frontier.empty()) {
    <span class="type">Location</span> <span class="variable-name">current</span> = frontier.front();
    frontier.pop();

    <span class="keyword">for</span> (<span class="type">Location</span> <span class="type">next</span> : graph.neighbors(current)) {
      <span class="keyword">if</span> (came_from.find(next) == came_from.end()) {
        frontier.push(next);
        came_from[next] = current;
      }
    }
  }
  <span class="keyword">return</span> came_from;
}

<span class="type">int</span> <span class="function-name">main</span>() {
  <span class="type">SquareGrid</span> <span class="variable-name">grid</span> = make_diagram1();
  <span class="type">GridLocation</span> <span class="variable-name">start</span>{7, 8};
  <span class="keyword">auto</span> <span class="variable-name">parents</span> = breadth_first_search(grid, start);
  draw_grid(grid, <span class="constant">nullptr</span>, &amp;parents, <span class="constant">nullptr</span>, &amp;start);
}
</pre></div>
<pre class="example" id="org6784b4a">__________________________________________________________________________________________
 &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt; ###### v  v  v  v  v  v  v 
 &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; ###### &gt;  v  v  v  v  v  v 
 &gt;  &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; ###### &gt;  &gt;  v  v  v  v  v 
 &gt;  &gt;  ^ ###### v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; ###### &gt;  &gt;  &gt;  v  v  v  v 
 &gt;  ^  ^ ###### v  v  v  v  v  v  v  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt; ###### &gt;  &gt;  &gt;  v  v  v  v 
 ^  ^  ^ ###### v  v  v  v  v  v  &lt;  &lt; ###### ^  ^  &lt;  &lt;  &lt;  &lt; ############### v  v  v  &lt; 
 v  v  v ###### v  v  v  v  v  &lt;  &lt;  &lt; ###### ^  ^  ^  &lt;  &lt;  &lt; ############### v  v  &lt;  &lt; 
 v  v  v ###### &gt;  v  v  v  &lt;  &lt;  &lt;  &lt; ###### ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  A  &lt;  &lt;  &lt;  &lt;  &lt; ###### ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  v ###### &gt;  ^  ^  ^  &lt;  &lt;  &lt;  &lt; ###### ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  v  v ###### ^  ^  ^  ^  ^  &lt;  &lt;  &lt; ###### ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  &gt;  v ###### ^  ^  ^  ^  ^  ^  &lt;  &lt; ###### ^  ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  &gt;  &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  &lt; ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt; 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>Some implementations use <em>internal storage</em>, creating a Node object to hold <code>came_from</code> and other values for each graph node. I’ve instead chosen to use <em>external storage</em>, creating a single <code>std::unordered_map</code> to store the <code>came_from</code> for all graph nodes. If you know your map locations have integer indices, another option is to use a 1D or 2D array/vector to store <code>came_from</code> and other values.</p>
<h3 id="cpp-early-exit">
<span class="section-number"> 2.2 </span><span>Early Exit</span><a class="anchor" aria-hidden="true" href="#cpp-early-exit">#</a>
</h3>
<p>Breadth First Search and Dijkstra’s Algorithm will explore the entire map by default. If we’re looking for a path to a single, point we can add <kbd>if (current == goal)</kbd> to exit the loop as soon as we find the path.</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">Location</span>, <span class="keyword">typename</span> <span class="type">Graph</span>&gt;
<span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt;
<span class="function-name">breadth_first_search</span>(<span class="type">Graph</span> <span class="variable-name">graph</span>, <span class="type">Location</span> <span class="variable-name">start</span>, <span class="type">Location</span> <span class="variable-name">goal</span>) {
  <span class="constant">std</span>::<span class="type">queue</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">frontier</span>;
  frontier.push(start);

  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt; <span class="variable-name">came_from</span>;
  came_from[start] = start;

  <span class="keyword">while</span> (<span class="negation-char">!</span>frontier.empty()) {
    <span class="type">Location</span> <span class="variable-name">current</span> = frontier.front();
    frontier.pop();

    <span class="keyword">if</span> (current == goal) {
      <span class="keyword">break</span>;
    }
    
    <span class="keyword">for</span> (<span class="type">Location</span> <span class="type">next</span> : graph.neighbors(current)) {
      <span class="keyword">if</span> (came_from.find(next) == came_from.end()) {
        frontier.push(next);
        came_from[next] = current;
      }
    }
  }
  <span class="keyword">return</span> came_from;
}

<span class="type">int</span> <span class="function-name">main</span>() {
  <span class="type">GridLocation</span> <span class="variable-name">start</span>{8, 7}, <span class="variable-name">goal</span>{17, 2};
  <span class="type">SquareGrid</span> <span class="variable-name">grid</span> = make_diagram1();
  <span class="keyword">auto</span> <span class="variable-name">came_from</span> = breadth_first_search(grid, start, goal);
  draw_grid(grid, <span class="constant">nullptr</span>, &amp;came_from, <span class="constant">nullptr</span>, &amp;start, &amp;goal);
}
</pre></div>
<pre class="example" id="org6ce2bce">__________________________________________________________________________________________
 .  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  v  v  &lt;  .  .  .  . ###### .  .  .  .  .  .  . 
 &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  .  .  . ###### .  .  .  .  .  .  . 
 &gt;  &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  Z  .  .  . ###### .  .  .  .  .  .  . 
 &gt;  &gt;  ^ ###### v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  .  . ###### .  .  .  .  .  .  . 
 .  ^  ^ ###### v  v  v  v  v  v  v  &lt; ###### ^  &lt;  &lt;  .  .  . ###### .  .  .  .  .  .  . 
 .  .  ^ ###### &gt;  v  v  v  v  v  &lt;  &lt; ###### ^  ^  .  .  .  . ############### .  .  .  . 
 .  .  . ###### &gt;  &gt;  v  v  v  &lt;  &lt;  &lt; ###### ^  .  .  .  .  . ############### .  .  .  . 
 .  .  . ###### &gt;  &gt;  &gt;  A  &lt;  &lt;  &lt;  &lt; ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### &gt;  &gt;  ^  ^  ^  &lt;  &lt;  &lt; ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  v ###### &gt;  ^  ^  ^  ^  ^  &lt;  &lt; ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  v  v ###### ^  ^  ^  ^  ^  ^  ^  &lt; ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 &gt;  &gt;  v ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 &gt;  &gt;  &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 &gt;  &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>You can see that the algorithm stops when it finds the goal <code>Z</code>. Early exit is also useful for <a href="../early-exit/">problems other than standard pathfinding</a>.</p>
<h3 id="cpp-dijkstra">
<span class="section-number"> 2.3 </span><span>Dijkstra’s Algorithm</span><a class="anchor" aria-hidden="true" href="#cpp-dijkstra">#</a>
</h3>
<p>This is what adds complexity to graph search, because we’re going to start processing locations in a better order than “first in, first out”. What do we need to change?</p>
<ol class="org-ol">
<li>The <em>graph</em> needs to know cost of movement.</li>
<li>The <em>queue</em> needs to return nodes in a different order.</li>
<li>The <em>search</em> needs to keep track of these costs from the graph and give them to the queue.</li>
</ol>
<h4 id="cpp-graph-with-weights">
<span><span class="section-number-4">2.3.1.</span> Graph with weights</span><a class="anchor" aria-hidden="true" href="#cpp-graph-with-weights">#</a>
</h4>
<p>A regular graph tells me the <code>neighbors</code> of each node. A <em>weighted</em> graph also tells me the cost of moving along each edge. I’m going to add a <code>cost(from_node, to_node)</code> function that tells us the cost of moving from location <code>from_node</code> to its neighbor <code>to_node</code>. In this forest map I chose to make movement depend only on <code>to_node</code>, but <a href="http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html">there are other types of movement that use both nodes</a><sup class="print-endnote">[4]</sup>. An alternate implementation would be to merge this into the <code>neighbors</code> function. Here’s a grid with a list of forest tiles, which will have movement cost 5:</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="keyword">struct</span> <span class="type">GridWithWeights</span>: <span class="type">SquareGrid</span> {
  <span class="constant">std</span>::<span class="type">unordered_set</span>&lt;GridLocation&gt; <span class="variable-name">forests</span>;
  <span class="function-name">GridWithWeights</span>(<span class="type">int</span> <span class="variable-name">w</span>, <span class="type">int</span> <span class="variable-name">h</span>): <span class="function-name">SquareGrid</span>(w, h) {}
  <span class="type">double</span> <span class="function-name">cost</span>(<span class="type">GridLocation</span> <span class="variable-name">from_node</span>, <span class="type">GridLocation</span> <span class="variable-name">to_node</span>) <span class="keyword">const</span> {
    <span class="keyword">return</span> forests.find(to_node) != forests.end()? 5 : 1;
  }
};
</pre></div>
<h4 id="cpp-queue-with-priorities">
<span><span class="section-number-4">2.3.2.</span> Queue with priorities</span><a class="anchor" aria-hidden="true" href="#cpp-queue-with-priorities">#</a>
</h4>
<p>We need a priority queue. C++ offers a <code>priority_queue</code> class that uses a binary heap but not the reprioritize operation. I’ll use a pair (priority, item) for the queue elements to get the right ordering. By default, the C++ priority queue returns the maximum element first, using the <code>std::less</code> comparator; we want the minimum element instead, so I’ll use the <code>std::greater</code> comparator.</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">T</span>, <span class="keyword">typename</span> <span class="type">priority_t</span>&gt;
<span class="keyword">struct</span> <span class="type">PriorityQueue</span> {
  <span class="keyword">typedef</span> <span class="constant">std</span>::<span class="type">pair</span>&lt;<span class="type">priority_t</span>, <span class="type">T</span>&gt; <span class="type">PQElement</span>;
  <span class="constant">std</span>::<span class="type">priority_queue</span>&lt;<span class="type">PQElement</span>, <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">PQElement</span>&gt;,
                 <span class="constant">std</span>::<span class="type">greater</span>&lt;<span class="type">PQElement</span>&gt;&gt; <span class="variable-name">elements</span>;

  <span class="keyword">inline</span> <span class="type">bool</span> <span class="function-name">empty</span>() <span class="keyword">const</span> {
     <span class="keyword">return</span> elements.empty();
  }

  <span class="keyword">inline</span> <span class="type">void</span> <span class="function-name">put</span>(<span class="type">T</span> <span class="variable-name">item</span>, <span class="type">priority_t</span> <span class="variable-name">priority</span>) {
    elements.emplace(priority, item);
  }

  <span class="type">T</span> <span class="function-name">get</span>() {
    <span class="type">T</span> <span class="variable-name">best_item</span> = elements.top().second;
    elements.pop();
    <span class="keyword">return</span> best_item;
  }
};
</pre></div>
<p>In this sample code I’m wrapping the C++ <code>std::priority_queue</code> class but I think it’d be reasonable to use that class directly without the wrapper.</p>
<h4 id="cpp-search">
<span><span class="section-number-4">2.3.3.</span> Search</span><a class="anchor" aria-hidden="true" href="#cpp-search">#</a>
</h4>
<p>See <a href="./introduction.html#dijkstra">the forest map from the main page</a>.</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">Location</span>, <span class="keyword">typename</span> <span class="type">Graph</span>&gt;
<span class="type">void</span> <span class="function-name">dijkstra_search</span>
  (<span class="type">Graph</span> <span class="variable-name">graph</span>,
   <span class="type">Location</span> <span class="variable-name">start</span>,
   <span class="type">Location</span> <span class="variable-name">goal</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt;&amp; <span class="variable-name">came_from</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">double</span>&gt;&amp; <span class="variable-name">cost_so_far</span>)
{
  <span class="type">PriorityQueue</span>&lt;<span class="type">Location</span>, <span class="type">double</span>&gt; <span class="variable-name">frontier</span>;
  frontier.put(start, 0);

  came_from[start] = start;
  cost_so_far[start] = 0;
  
  <span class="keyword">while</span> (<span class="negation-char">!</span>frontier.empty()) {
    <span class="type">Location</span> <span class="variable-name">current</span> = frontier.get();

    <span class="keyword">if</span> (current == goal) {
      <span class="keyword">break</span>;
    }

    <span class="keyword">for</span> (<span class="type">Location</span> <span class="type">next</span> : graph.neighbors(current)) {
      <span class="type">double</span> <span class="variable-name">new_cost</span> = cost_so_far[current] + graph.cost(current, next);
      <span class="keyword">if</span> (cost_so_far.find(next) == cost_so_far.end()
          || new_cost &lt; cost_so_far[next]) {
        cost_so_far[next] = new_cost;
        came_from[next] = current;
        frontier.put(next, new_cost);
      }
    }
  }
}
</pre></div>
<p>The types of the <code>cost</code> variables should all match the types used in the graph. If you use <code>int</code> then you can use <code>int</code> for the cost variable and the priorities in the priority queue; if you use <code>double</code> then you should use <code>double</code> for these. In this code I used <code>double</code> but I could’ve used <code>int</code> and it would’ve worked the same. However, if your graph edge costs are doubles or if your heuristic uses doubles, then you’ll need to use doubles here.</p>
<p>Finally, after searching I need to build the path:</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">Location</span>&gt;
<span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">Location</span>&gt; <span class="function-name">reconstruct_path</span>(
   <span class="type">Location</span> <span class="variable-name">start</span>, <span class="type">Location</span> <span class="variable-name">goal</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt; <span class="variable-name">came_from</span>
) {
  <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">path</span>;
  <span class="type">Location</span> <span class="variable-name">current</span> = goal;
  <span class="keyword">if</span> (came_from.find(goal) == came_from.end()) {
    <span class="keyword">return</span> path; <span class="comment-delimiter">// </span><span class="comment">no path can be found</span>
  }
  <span class="keyword">while</span> (current != start) {
    path.push_back(current);
    current = came_from[current];
  }
  path.push_back(start); <span class="comment-delimiter">// </span><span class="comment">optional</span>
  <span class="constant">std</span>::reverse(path.begin(), path.end());
  <span class="keyword">return</span> path;
}
</pre></div>
<p>Although paths are best thought of as a sequence of edges, it’s convenient to store them as a sequence of nodes. To build the path, start at the end and follow the <code>came_from</code> map, which points to the previous node. When we reach start, we’re done. It is the <strong>backwards</strong> path, so call <code>reverse()</code> at the end of <code>reconstruct_path</code> if you need it to be stored forwards. Sometimes it’s actually more convenient to store it backwards. Sometimes it’s useful to also store the start node in the list.</p>
<p>Let’s try it out:</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="type">int</span> <span class="function-name">main</span>() {
  <span class="type">GridWithWeights</span> <span class="variable-name">grid</span> = make_diagram4();
  <span class="type">GridLocation</span> <span class="variable-name">start</span>{1, 4}, <span class="variable-name">goal</span>{8, 3};
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">GridLocation</span>, <span class="type">GridLocation</span>&gt; <span class="variable-name">came_from</span>;
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">GridLocation</span>, <span class="type">double</span>&gt; <span class="variable-name">cost_so_far</span>;
  dijkstra_search(grid, start, goal, came_from, cost_so_far);
  draw_grid(grid, <span class="constant">nullptr</span>, &amp;came_from, <span class="constant">nullptr</span>, &amp;start, &amp;goal);
  <span class="constant">std</span>::cout &lt;&lt; <span class="string">'\n'</span>;
  <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">GridLocation</span>&gt; <span class="variable-name">path</span> = reconstruct_path(start, goal, came_from);
  draw_grid(grid, <span class="constant">nullptr</span>, <span class="constant">nullptr</span>, &amp;path, &amp;start, &amp;goal);
}
</pre></div>
<pre class="example" id="org500161d">______________________________
 v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  &lt;  &lt;  &lt;  ^  ^  &lt;  &lt;  &lt; 
 v  v  &lt;  &lt;  &lt;  &lt;  ^  ^  &lt;  &lt; 
 v  v  &lt;  &lt;  &lt;  &lt;  &lt;  ^  Z  . 
 &gt;  A  &lt;  &lt;  &lt;  &lt;  .  .  .  . 
 ^  ^  &lt;  &lt;  &lt;  &lt;  .  .  .  . 
 ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  .  .  . 
 ^ ######### ^  &lt;  v  v  .  . 
 ^ ######### v  v  v  &lt;  &lt;  . 
 ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

______________________________
 .  @  @  @  @  @  @  .  .  . 
 .  @  .  .  .  .  @  @  .  . 
 .  @  .  .  .  .  .  @  @  . 
 .  @  .  .  .  .  .  .  Z  . 
 .  A  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
 . ######### .  .  .  .  .  . 
 . ######### .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>Why is the path going up and over? Remember that this is the forest example from the main page, where the middle of the map has a big forest that’s slow to move through. The shortest path goes around the forest, not through it.</p>
<p>The results are not always the same as the Python version because I’m using the built-in priority queues in C++ and Python. These may order equal-valued nodes differently. <strong>This is something you’ll run into if using grids</strong>. There are <em>many</em> equally short paths, and the pathfinder will find <em>one</em> of them, not necessarily the one that looks the best to your eye.</p>
<h4 id="cpp-no-path">
<span><span class="section-number-4">2.3.4.</span> No path</span><a class="anchor" aria-hidden="true" href="#cpp-no-path">#</a>
</h4>
<p>There’s a tricky case — what if there’s no path? Let’s try a wall that completely blocks the left and right sides from each other.</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="type">int</span> <span class="function-name">main</span>() {
  <span class="type">GridWithWeights</span> <span class="variable-name">grid</span> = make_diagram_nopath();
  <span class="type">GridLocation</span> <span class="variable-name">start</span>{1, 4}, <span class="variable-name">goal</span>{8, 3};
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">GridLocation</span>, <span class="type">GridLocation</span>&gt; <span class="variable-name">came_from</span>;
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">GridLocation</span>, <span class="type">double</span>&gt; <span class="variable-name">cost_so_far</span>;
  dijkstra_search(grid, start, goal, came_from, cost_so_far);
  draw_grid(grid, <span class="constant">nullptr</span>, &amp;came_from, <span class="constant">nullptr</span>, &amp;start, &amp;goal);
  <span class="comment-delimiter">// </span><span class="comment">reconstruct_path(start, goal, came_from) returns an empty vector</span>
}
</pre></div>
<pre class="example" id="org9b21fcf">______________________________
 v  v  &lt;  &lt;  &lt; ### .  .  .  . 
 v  v  &lt;  &lt;  &lt; ### .  .  .  . 
 v  v  &lt;  &lt;  &lt; ### .  .  .  . 
 v  v  &lt;  &lt;  &lt; ### .  .  Z  . 
 &gt;  A  &lt;  &lt;  &lt; ### .  .  .  . 
 ^  ^  &lt;  &lt;  &lt; ### .  .  .  . 
 ^  ^  &lt;  &lt;  &lt; ### .  .  .  . 
 ^  ^  &lt;  &lt;  &lt; ### .  .  .  . 
 ^  ^  &lt;  &lt;  &lt; ### .  .  .  . 
 ^  ^  &lt;  &lt;  &lt; ### .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>The search algorithm will try to explore as much as it can but it just can’t get from <kbd>A</kbd> to <kbd>Z</kbd>. We can detect this in <code>reconstruct_path</code> because <code>goal</code> will not be in the <code>came_from</code> map. It can still be <em>slow</em> though, as the search algorithm has to explore every nook and cranny before realizing there’s no path. If you can, pre-process the map with <a href="https://en.wikipedia.org/wiki/Connected-component_labeling">connected component labeling</a><sup class="print-endnote">[5]</sup> to determine whether there’s a path <em>before</em> running graph search.</p>
<h4 id="cpp-distance-field">
<span><span class="section-number-4">2.3.5.</span> Distance fields</span><a class="anchor" aria-hidden="true" href="#cpp-distance-field">#</a>
</h4>
<p>Collecting distances instead of directions gives us a <em>distance field</em>. Here’s an example of computing the distance from the start location <kbd>A</kbd> with a dummy value for the goal <kbd>Z</kbd>:</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="type">int</span> <span class="function-name">main</span>() {
  <span class="type">GridWithWeights</span> <span class="variable-name">grid</span> = make_diagram4();
  <span class="type">GridLocation</span> <span class="variable-name">start</span>{1, 4}, <span class="variable-name">goal</span>{-1, -1};
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">GridLocation</span>, <span class="type">GridLocation</span>&gt; <span class="variable-name">came_from</span>;
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">GridLocation</span>, <span class="type">double</span>&gt; <span class="variable-name">cost_so_far</span>;
  dijkstra_search(grid, start, goal, came_from, cost_so_far);
  draw_grid(grid, &amp;cost_so_far, <span class="constant">nullptr</span>, <span class="constant">nullptr</span>, &amp;start, &amp;goal);
}
</pre></div>
<pre class="example" id="org67dd33a">______________________________
 5  4  5  6  7  8  9  10 11 12
 4  3  4  5  10 13 10 11 12 13
 3  2  3  4  9  14 15 12 13 14
 2  1  2  3  8  13 18 17 14 15
 1  A  1  6  11 16 21 20 15 16
 2  1  2  7  12 17 22 21 16 17
 3  2  3  4  9  14 19 16 17 18
 4 ######### 14 19 18 15 16 17
 5 ######### 15 16 13 14 15 16
 6  7  8  9  10 11 12 13 14 15
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>Distance fields can be useful for some <a href="../distance-to-any/">variants of pathfinding</a>. For these I’ll often run the search algorithm <em>without</em> early exit, or with <a href="../early-exit/">a different type of early exit</a>.</p>
<h3 id="cpp-astar">
<span class="section-number"> 2.4 </span><span>A* Search</span><a class="anchor" aria-hidden="true" href="#cpp-astar">#</a>
</h3>
<p>A* is almost exactly like Dijkstra’s Algorithm, except we add in a heuristic. Note that the code for the algorithm <em>isn’t specific to grids</em>. Knowledge about grids is in the graph class (<code>GridWithWeights</code>), the locations (<code>Location</code> struct), and in the <code>heuristic</code> function. Replace those three and you can use the A* algorithm code with any other graph structure.</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="keyword">inline</span> <span class="type">double</span> <span class="function-name">heuristic</span>(<span class="type">GridLocation</span> <span class="variable-name">a</span>, <span class="type">GridLocation</span> <span class="variable-name">b</span>) {
  <span class="keyword">return</span> <span class="constant">std</span>::abs(a.x - b.x) + <span class="constant">std</span>::abs(a.y - b.y);
}

<span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">Location</span>, <span class="keyword">typename</span> <span class="type">Graph</span>&gt;
<span class="type">void</span> <span class="function-name">a_star_search</span>
  (<span class="type">Graph</span> <span class="variable-name">graph</span>,
   <span class="type">Location</span> <span class="variable-name">start</span>,
   <span class="type">Location</span> <span class="variable-name">goal</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt;&amp; <span class="variable-name">came_from</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">Location</span>, <span class="type">double</span>&gt;&amp; <span class="variable-name">cost_so_far</span>)
{
  <span class="type">PriorityQueue</span>&lt;<span class="type">Location</span>, <span class="type">double</span>&gt; <span class="variable-name">frontier</span>;
  frontier.put(start, 0);

  came_from[start] = start;
  cost_so_far[start] = 0;
  
  <span class="keyword">while</span> (<span class="negation-char">!</span>frontier.empty()) {
    <span class="type">Location</span> <span class="variable-name">current</span> = frontier.get();

    <span class="keyword">if</span> (current == goal) {
      <span class="keyword">break</span>;
    }

    <span class="keyword">for</span> (<span class="type">Location</span> <span class="type">next</span> : graph.neighbors(current)) {
      <span class="type">double</span> <span class="variable-name">new_cost</span> = cost_so_far[current] + graph.cost(current, next);
      <span class="keyword">if</span> (cost_so_far.find(next) == cost_so_far.end()
          || new_cost &lt; cost_so_far[next]) {
        cost_so_far[next] = new_cost;
        <span class="type">double</span> <span class="variable-name">priority</span> = new_cost + heuristic(next, goal);
        frontier.put(next, priority);
        came_from[next] = current;
      }
    }
  }
}
</pre></div>
<p>The type of the <code>priority</code> values including the type used in the priority queue should be big enough to include both the graph costs (<code>cost_t</code>) and the heuristic value. For example, if the graph costs are ints and the heuristic returns a double, then you need the priority queue to accept doubles. In this sample code I use <code>double</code> for all three (cost, heuristic, and priority), but I could’ve used <code>int</code> because my costs and heuristics are integer valued.</p>
<p>Minor note: It would be more correct to write <code>frontier.put(start, heuristic(start, goal))</code> than <code>frontier.put(start, 0)</code> but it makes no difference here because the start node’s priority doesn’t matter. It is the only node in the priority queue and it is selected and removed before anything else is put in there.</p>
<p>Let’s try it out:</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="preprocessor">#include</span> <span class="string">"redblobgames/pathfinding/a-star/implementation.cpp"</span>

<span class="type">int</span> <span class="function-name">main</span>() {
  <span class="type">GridWithWeights</span> <span class="variable-name">grid</span> = make_diagram4();
  <span class="type">GridLocation</span> <span class="variable-name">start</span>{1, 4}, <span class="variable-name">goal</span>{8, 3};
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">GridLocation</span>, <span class="type">GridLocation</span>&gt; <span class="variable-name">came_from</span>;
  <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="type">GridLocation</span>, <span class="type">double</span>&gt; <span class="variable-name">cost_so_far</span>;
  a_star_search(grid, start, goal, came_from, cost_so_far);
  draw_grid(grid, <span class="constant">nullptr</span>, &amp;came_from, <span class="constant">nullptr</span>, &amp;start, &amp;goal);
  <span class="constant">std</span>::cout &lt;&lt; <span class="string">'\n'</span>;
  <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">GridLocation</span>&gt; <span class="variable-name">path</span> = reconstruct_path(start, goal, came_from);
  draw_grid(grid, <span class="constant">nullptr</span>, <span class="constant">nullptr</span>, &amp;path, &amp;start, &amp;goal);
  <span class="constant">std</span>::cout &lt;&lt; <span class="string">'\n'</span>;
  draw_grid(grid, &amp;cost_so_far, <span class="constant">nullptr</span>, <span class="constant">nullptr</span>, &amp;start, &amp;goal);
}
</pre></div>
<pre class="example" id="org13466eb">______________________________
 v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  v  v  &lt;  ^  ^  &lt;  &lt;  &lt; 
 v  v  v  v  &lt;  &lt;  ^  ^  &lt;  &lt; 
 &gt;  v  &lt;  &lt;  &lt;  &lt;  .  ^  Z  . 
 &gt;  A  &lt;  &lt;  &lt;  .  .  .  .  . 
 ^  ^  ^  &lt;  &lt;  .  .  .  .  . 
 ^  ^  ^  &lt;  &lt;  .  .  .  .  . 
 ^ ######### .  .  .  .  .  . 
 . ######### .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

______________________________
 .  .  .  @  @  @  @  .  .  . 
 .  .  .  @  .  .  @  @  .  . 
 .  .  .  @  .  .  .  @  @  . 
 .  @  @  @  .  .  .  .  Z  . 
 .  A  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
 . ######### .  .  .  .  .  . 
 . ######### .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

______________________________
 5  4  5  6  7  8  9  10 11 12
 4  3  4  5  10 13 10 11 12 13
 3  2  3  4  9  14 15 12 13 14
 2  1  2  3  8  13 .  17 Z  . 
 1  A  1  6  11 .  .  .  .  . 
 2  1  2  7  12 .  .  .  .  . 
 3  2  3  4  9  .  .  .  .  . 
 4 ######### .  .  .  .  .  . 
 . ######### .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>And that’s it! We’ve implemented graphs, grids, Breadth First Search, Dijkstra’s Algorithm, and A*.</p>
<h4 id="cpp-straighter-paths">
<span><span class="section-number-4">2.4.1.</span> Straighter paths</span><a class="anchor" aria-hidden="true" href="#cpp-straighter-paths">#</a>
</h4>
<p>If you implement this code in your own project you might find that some of the paths aren’t as “straight” as you’d like. <strong>This is normal</strong>. When using <em>grids</em>, especially grids where every step has the same movement cost, you end up with <strong>ties</strong>: many paths have exactly the same cost. A* ends up picking one of the many short paths, and often <strong>it won’t look good to you</strong>. I list <a href="#troubleshooting-ugly-path">some solutions</a> in a later section.</p>
<h3 id="cpp-production">
<span class="section-number"> 2.5 </span><span>Production code</span><a class="anchor" aria-hidden="true" href="#cpp-production">#</a>
</h3>
<p>The C++ code I’ve shown above is simplified to make it easier to follow the algorithm and data structures. In practice there are many things you’d want to do differently:</p>
<ul class="org-ul">
<li>inlining small functions</li>
<li>the <code>Location</code> parameter should be part of the <code>Graph</code>
</li>
<li>the cost could be int or double, and should be part of the <code>Graph</code>
</li>
<li>use <code>array</code> instead of <code>unordered_set</code> if the ids are dense integers, and reset these values on exit instead of initializing on entry</li>
<li>pass larger data structures by reference instead of by value</li>
<li>return larger data structures in out parameters instead of returning them, or use move constructors (for example, the vector returned from the <code>neighbors</code> function)</li>
<li>the heuristic can vary and should be a template parameter to the A* function so that it can be inlined</li>
</ul>
<p>Here’s how the A* code might look different with some (but not all) of these changes:</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="type">Graph</span>&gt;
<span class="type">void</span> <span class="function-name">a_star_search</span>
  (<span class="type">Graph</span> <span class="variable-name">graph</span>,
   <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span> <span class="variable-name">start</span>,
   <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span> <span class="variable-name">goal</span>,
   <span class="constant">std</span>::<span class="type">function</span>&lt;<span class="keyword">typename</span> <span class="constant">Graph</span>::cost_t(<span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span> <span class="variable-name">a</span>,
                                        <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span> <span class="variable-name">b</span>)&gt; <span class="variable-name">heuristic</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span>,
                      <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span>&gt;&amp; <span class="variable-name">came_from</span>,
   <span class="constant">std</span>::<span class="type">unordered_map</span>&lt;<span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span>,
                      <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">cost_t</span>&gt;&amp; <span class="variable-name">cost_so_far</span>)
{
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">Location</span> <span class="type">Location</span>;
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="constant">Graph</span>::<span class="type">cost_t</span> <span class="type">cost_t</span>;
  <span class="type">PriorityQueue</span>&lt;<span class="type">Location</span>, <span class="type">cost_t</span>&gt; <span class="variable-name">frontier</span>;
  <span class="constant">std</span>::<span class="type">vector</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">neighbors</span>;
  frontier.put(start, cost_t(0));

  came_from[start] = start;
  cost_so_far[start] = cost_t(0);
  
  <span class="keyword">while</span> (<span class="negation-char">!</span>frontier.empty()) {
    <span class="keyword">typename</span> <span class="type">Location</span> <span class="variable-name">current</span> = frontier.get();

    <span class="keyword">if</span> (current == goal) {
      <span class="keyword">break</span>;
    }

    graph.get_neighbors(current, neighbors);
    <span class="keyword">for</span> (<span class="type">Location</span> <span class="type">next</span> : neighbors) {
      <span class="type">cost_t</span> <span class="variable-name">new_cost</span> = cost_so_far[current] + graph.cost(current, next);
      <span class="keyword">if</span> (cost_so_far.find(next) == cost_so_far.end()
          || new_cost &lt; cost_so_far[next]) {
        cost_so_far[next] = new_cost;
        <span class="type">cost_t</span> <span class="variable-name">priority</span> = new_cost + heuristic(next, goal);
        frontier.put(next, priority);
        came_from[next] = current;
      }
    }
  }
}
</pre></div>
<p>I wanted the code on this page to be about the algorithms and data structures and not about the C++ optimizations so I tried to show simple code instead of fast or abstract code.</p></section><section><h2 id="csharp">
<span class="section-number"> 3  </span><span><a href="#csharp"> C# Implementation</a></span><a class="anchor" href="#csharp">#</a>
</h2>
<p>These were my first C# programs so they might not be idiomatic or stylistically proper. These examples aren’t as complete as the Python and C++ sections, but I hope they’re helpful.</p>
<p>Here’s a simple graph, and Breadth First Search:</p>
<div class="org-src-container"><pre class="src src-csharp"><span class="keyword">using</span> <span class="variable-name">System</span>;
<span class="keyword">using</span> <span class="variable-name">System</span>.<span class="variable-name">Collections</span>.<span class="variable-name">Generic</span>;


<span class="keyword">public</span> <span class="keyword">class</span> <span class="type">Graph</span>&lt;<span class="type">Location</span>&gt;
{
    <span class="comment-delimiter">// </span><span class="comment">NameValueCollection would be a reasonable alternative here, if</span>
    <span class="comment-delimiter">// </span><span class="comment">you're always using string location types</span>
    <span class="keyword">public</span> <span class="type">Dictionary</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>[]&gt; <span class="variable-name">edges</span>
        = <span class="keyword">new</span> <span class="type">Dictionary</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>[]&gt;();

    <span class="keyword">public</span> <span class="type">Location</span>[] <span class="function-name">Neighbors</span>(<span class="type">Location</span> <span class="variable-name">id</span>)
    {
        <span class="keyword">return</span> edges[id];
    }
};


<span class="keyword">class</span> <span class="type">BreadthFirstSearch</span>
{
    <span class="keyword">static</span> <span class="type">void</span> <span class="function-name">Search</span>(<span class="type">Graph</span>&lt;<span class="type">string</span>&gt; <span class="variable-name">graph</span>, <span class="type">string</span> <span class="variable-name">start</span>)
    {
        <span class="type">var</span> <span class="variable-name">frontier</span> = <span class="keyword">new</span> <span class="type">Queue</span>&lt;<span class="type">string</span>&gt;();
        frontier.<span class="function-name">Enqueue</span>(<span class="type">start</span>);

        <span class="type">var</span> <span class="variable-name">reached</span> = <span class="keyword">new</span> <span class="type">HashSet</span>&lt;<span class="type">string</span>&gt;();
        reached.<span class="function-name">Add</span>(<span class="type">start</span>);

        <span class="keyword">while</span> (frontier.Count &gt; 0)
        {
            <span class="type">var</span> <span class="variable-name">current</span> = frontier.<span class="function-name">Dequeue</span>();

            Console.<span class="function-name">WriteLine</span>(<span class="string">"Visiting {0}"</span>, <span class="type">current</span>);
            <span class="keyword">foreach</span> (<span class="type">var</span> <span class="variable-name">next</span> <span class="keyword">in</span> graph.<span class="function-name">Neighbors</span>(<span class="type">current</span>))
            {
                <span class="keyword">if</span> (<span class="negation-char">!</span>reached.<span class="function-name">Contains</span>(<span class="type">next</span>)) {
                    frontier.<span class="function-name">Enqueue</span>(<span class="type">next</span>);
                    reached.<span class="function-name">Add</span>(<span class="type">next</span>);
                }
            }
        }
    }
    
    <span class="keyword">static</span> <span class="type">void</span> <span class="function-name">Main</span>()
    {
        <span class="type">Graph</span>&lt;<span class="type">string</span>&gt; <span class="variable-name">g</span> = <span class="keyword">new</span> <span class="type">Graph</span>&lt;<span class="type">string</span>&gt;();
        g.edges = <span class="keyword">new</span> <span class="type">Dictionary</span>&lt;<span class="type">string</span>, <span class="type">string</span>[]&gt;
            {
            { <span class="string">"A"</span>, <span class="keyword">new</span> [] { <span class="string">"B"</span> } },
            { <span class="string">"B"</span>, <span class="keyword">new</span> [] { <span class="string">"A"</span>, <span class="string">"C"</span>, <span class="string">"D"</span> } },
            { <span class="string">"C"</span>, <span class="keyword">new</span> [] { <span class="string">"A"</span> } },
            { <span class="string">"D"</span>, <span class="keyword">new</span> [] { <span class="string">"E"</span>, <span class="string">"A"</span> } },
            { <span class="string">"E"</span>, <span class="keyword">new</span> [] { <span class="string">"B"</span> } }
        };

        <span class="function-name">Search</span>(<span class="type">g</span>, <span class="string">"A"</span>);
    }
}
</pre></div>
<p>Here’s a graph representing a grid with weighted edges (the forest and walls example from the main page):</p>
<div class="org-src-container"><pre class="src src-csharp"><span class="keyword">using</span> <span class="variable-name">System</span>;
<span class="keyword">using</span> <span class="variable-name">System</span>.<span class="variable-name">Collections</span>.<span class="variable-name">Generic</span>;

<span class="comment-delimiter">// </span><span class="comment">A* needs only a WeightedGraph and a location type L, and does *not*</span>
<span class="comment-delimiter">// </span><span class="comment">have to be a grid. However, in the example code I am using a grid.</span>
<span class="keyword">public</span> <span class="keyword">interface</span> <span class="type">WeightedGraph</span>&lt;<span class="type">L</span>&gt;
{
    <span class="type">double</span> <span class="function-name">Cost</span>(<span class="type">Location</span> <span class="variable-name">a</span>, <span class="type">Location</span> <span class="variable-name">b</span>);
    <span class="type">IEnumerable</span>&lt;<span class="type">Location</span>&gt; <span class="function-name">Neighbors</span>(<span class="type">Location</span> <span class="variable-name">id</span>);
}


<span class="keyword">public</span> <span class="keyword">struct</span> <span class="type">Location</span>
{
    <span class="comment-delimiter">// </span><span class="comment">Implementation notes: I am using the default Equals but it can</span>
    <span class="comment-delimiter">// </span><span class="comment">be slow. You'll probably want to override both Equals and</span>
    <span class="comment-delimiter">// </span><span class="comment">GetHashCode in a real project.</span>
    
    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="type">int</span> <span class="variable-name">x</span>, <span class="variable-name">y</span>;
    <span class="keyword">public</span> <span class="function-name">Location</span>(<span class="type">int</span> <span class="variable-name">x</span>, <span class="type">int</span> <span class="variable-name">y</span>)
    {
        <span class="keyword">this</span>.x = x;
        <span class="keyword">this</span>.y = y;
    }
}


<span class="keyword">public</span> <span class="keyword">class</span> <span class="type">SquareGrid</span> : <span class="type">WeightedGraph</span>&lt;<span class="type">Location</span>&gt;
{
    <span class="comment-delimiter">// </span><span class="comment">Implementation notes: I made the fields public for convenience,</span>
    <span class="comment-delimiter">// </span><span class="comment">but in a real project you'll probably want to follow standard</span>
    <span class="comment-delimiter">// </span><span class="comment">style and make them private.</span>
    
    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="type">Location</span>[] <span class="variable-name">DIRS</span> = <span class="keyword">new</span> []
        {
            <span class="keyword">new</span> <span class="type">Location</span>(1, 0),
            <span class="keyword">new</span> <span class="type">Location</span>(0, -1),
            <span class="keyword">new</span> <span class="type">Location</span>(-1, 0),
            <span class="keyword">new</span> <span class="type">Location</span>(0, 1)
        };

    <span class="keyword">public</span> <span class="type">int</span> <span class="variable-name">width</span>, <span class="variable-name">height</span>;
    <span class="keyword">public</span> <span class="type">HashSet</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">walls</span> = <span class="keyword">new</span> <span class="type">HashSet</span>&lt;<span class="type">Location</span>&gt;();
    <span class="keyword">public</span> <span class="type">HashSet</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">forests</span> = <span class="keyword">new</span> <span class="type">HashSet</span>&lt;<span class="type">Location</span>&gt;();

    <span class="keyword">public</span> <span class="function-name">SquareGrid</span>(<span class="type">int</span> <span class="variable-name">width</span>, <span class="type">int</span> <span class="variable-name">height</span>)
    {
        <span class="keyword">this</span>.width = width;
        <span class="keyword">this</span>.height = height;
    }

    <span class="keyword">public</span> <span class="type">bool</span> <span class="function-name">InBounds</span>(<span class="type">Location</span> <span class="variable-name">id</span>)
    {
        <span class="keyword">return</span> 0 &lt;= id.x &amp;&amp; id.x &lt; width
            &amp;&amp; 0 &lt;= id.y &amp;&amp; id.y &lt; height;
    }

    <span class="keyword">public</span> <span class="type">bool</span> <span class="function-name">Passable</span>(<span class="type">Location</span> <span class="variable-name">id</span>)
    {
        <span class="keyword">return</span> <span class="negation-char">!</span>walls.<span class="function-name">Contains</span>(id);
    }

    <span class="keyword">public</span> <span class="type">double</span> <span class="function-name">Cost</span>(<span class="type">Location</span> <span class="variable-name">a</span>, <span class="type">Location</span> <span class="variable-name">b</span>)
    {
        <span class="keyword">return</span> forests.<span class="function-name">Contains</span>(b) ? 5 : 1;
    }
    
    <span class="keyword">public</span> <span class="type">IEnumerable</span>&lt;<span class="type">Location</span>&gt; <span class="function-name">Neighbors</span>(<span class="type">Location</span> <span class="variable-name">id</span>)
    {
        <span class="keyword">foreach</span> (<span class="type">var</span> <span class="variable-name">dir</span> <span class="keyword">in</span> DIRS) {
            <span class="type">Location</span> <span class="variable-name">next</span> = <span class="keyword">new</span> <span class="type">Location</span>(id.x + dir.x, id.y + dir.y);
            <span class="keyword">if</span> (<span class="function-name">InBounds</span>(next) &amp;&amp; <span class="function-name">Passable</span>(next)) {
                <span class="keyword">yield</span> <span class="keyword">return</span> next;
            }
        }
    }
}


<span class="comment-delimiter">// </span><span class="comment">When I wrote this code in 2015, C# didn't have a PriorityQueue&lt;&gt;</span>
<span class="comment-delimiter">// </span><span class="comment">class. It was added in 2020; see</span>
<span class="comment-delimiter">// </span><span class="comment">https://github.com/dotnet/runtime/issues/14032</span>
<span class="comment-delimiter">//</span>
<span class="comment-delimiter">// </span><span class="comment">This is a placeholder PriorityQueue&lt;&gt; that runs inefficiently but</span>
<span class="comment-delimiter">// </span><span class="comment">will allow you to run the sample code on older C# implementations.</span>
<span class="comment-delimiter">//</span>
<span class="comment-delimiter">// </span><span class="comment">If you're using a version of C# that doesn't have PriorityQueue&lt;&gt;,</span>
<span class="comment-delimiter">// </span><span class="comment">consider using one of these fast libraries instead of my slow</span>
<span class="comment-delimiter">// </span><span class="comment">placeholder:</span>
<span class="comment-delimiter">//</span>
<span class="comment-delimiter">// </span><span class="comment">* https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp</span>
<span class="comment-delimiter">// </span><span class="comment">* https://visualstudiomagazine.com/articles/2012/11/01/priority-queues-with-c.aspx</span>
<span class="comment-delimiter">// </span><span class="comment">* http://xfleury.github.io/graphsearch.html</span>
<span class="comment-delimiter">// </span><span class="comment">* http://stackoverflow.com/questions/102398/priority-queue-in-net</span>
<span class="keyword">public</span> <span class="keyword">class</span> <span class="type">PriorityQueue</span>&lt;<span class="type">TElement</span>, <span class="type">TPriority</span>&gt;
{
    <span class="keyword">private</span> <span class="type">List</span>&lt;<span class="type">Tuple</span>&lt;<span class="type">TElement</span>, <span class="type">TPriority</span>&gt;&gt; <span class="variable-name">elements</span> = <span class="keyword">new</span> <span class="type">List</span>&lt;<span class="type">Tuple</span>&lt;<span class="type">TElement</span>, <span class="type">TPriority</span>&gt;&gt;();

    <span class="keyword">public</span> <span class="type">int</span> <span class="variable-name">Count</span>
    {
        <span class="keyword">get</span> { <span class="keyword">return</span> elements.Count; }
    }
    
    <span class="keyword">public</span> <span class="type">void</span> <span class="function-name">Enqueue</span>(<span class="type">TElement</span> <span class="variable-name">item</span>, <span class="type">TPriority</span> <span class="variable-name">priority</span>)
    {
        elements.<span class="function-name">Add</span>(Tuple.<span class="function-name">Create</span>(<span class="type">item</span>, <span class="type">priority</span>));
    }

    <span class="keyword">public</span> <span class="type">TElement</span> <span class="function-name">Dequeue</span>()
    {
        <span class="type">Comparer</span>&lt;<span class="type">TPriority</span>&gt; <span class="variable-name">comparer</span> = <span class="constant">Comparer</span>&lt;<span class="type">TPriority</span>&gt;.Default;
        <span class="type">int</span> <span class="variable-name">bestIndex</span> = 0;

        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable-name">i</span> = 0; i &lt; elements.Count; i++) {
            <span class="keyword">if</span> (comparer.<span class="function-name">Compare</span>(<span class="type">elements</span>[i].Item2, <span class="type">elements</span>[bestIndex].Item2) &lt; 0) {
                bestIndex = i;
            }
        }

        <span class="type">TElement</span> <span class="variable-name">bestItem</span> = elements[bestIndex].Item1;
        elements.<span class="function-name">RemoveAt</span>(<span class="type">bestIndex</span>);
        <span class="keyword">return</span> bestItem;
    }
}


<span class="comment-delimiter">/* </span><span class="comment">NOTE about types: in the main article, in the Python code I just</span>
<span class="comment"> * use numbers for costs, heuristics, and priorities. In the C++ code</span>
<span class="comment"> * I use a typedef for this, because you might want int or double or</span>
<span class="comment"> * another type. In this C# code I use double for costs, heuristics,</span>
<span class="comment"> * and priorities. You can use an int if you know your values are</span>
<span class="comment"> * always integers, and you can use a smaller size number if you know</span>
<span class="comment"> * the values are always small.</span><span class="comment-delimiter"> */</span>

<span class="keyword">public</span> <span class="keyword">class</span> <span class="type">AStarSearch</span>
{
    <span class="keyword">public</span> <span class="type">Dictionary</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt; <span class="variable-name">cameFrom</span>
        = <span class="keyword">new</span> <span class="type">Dictionary</span>&lt;<span class="type">Location</span>, <span class="type">Location</span>&gt;();
    <span class="keyword">public</span> <span class="type">Dictionary</span>&lt;<span class="type">Location</span>, <span class="type">double</span>&gt; <span class="variable-name">costSoFar</span>
        = <span class="keyword">new</span> <span class="type">Dictionary</span>&lt;<span class="type">Location</span>, <span class="type">double</span>&gt;();

    <span class="comment-delimiter">// </span><span class="comment">Note: a generic version of A* would abstract over Location and</span>
    <span class="comment-delimiter">// </span><span class="comment">also Heuristic</span>
    <span class="keyword">static</span> <span class="keyword">public</span> <span class="type">double</span> <span class="function-name">Heuristic</span>(<span class="type">Location</span> <span class="variable-name">a</span>, <span class="type">Location</span> <span class="variable-name">b</span>)
    {
        <span class="keyword">return</span> Math.<span class="function-name">Abs</span>(a.x - b.x) + Math.<span class="function-name">Abs</span>(a.y - b.y);
    }

    <span class="keyword">public</span> <span class="function-name">AStarSearch</span>(<span class="type">WeightedGraph</span>&lt;<span class="type">Location</span>&gt; <span class="variable-name">graph</span>, <span class="type">Location</span> <span class="variable-name">start</span>, <span class="type">Location</span> <span class="variable-name">goal</span>)
    {
        <span class="type">var</span> <span class="variable-name">frontier</span> = <span class="keyword">new</span> <span class="type">PriorityQueue</span>&lt;<span class="type">Location</span>, <span class="type">double</span>&gt;();
        frontier.<span class="function-name">Enqueue</span>(<span class="type">start</span>, 0);

        cameFrom[start] = start;
        costSoFar[start] = 0;

        <span class="keyword">while</span> (frontier.Count &gt; 0)
        {
            <span class="type">var</span> <span class="variable-name">current</span> = frontier.<span class="function-name">Dequeue</span>();

            <span class="keyword">if</span> (current.<span class="function-name">Equals</span>(<span class="type">goal</span>))
            {
                <span class="keyword">break</span>;
            }

            <span class="keyword">foreach</span> (<span class="type">var</span> <span class="variable-name">next</span> <span class="keyword">in</span> graph.<span class="function-name">Neighbors</span>(<span class="type">current</span>))
            {
                <span class="type">double</span> <span class="variable-name">newCost</span> = costSoFar[current]
                    + graph.<span class="function-name">Cost</span>(<span class="type">current</span>, <span class="type">next</span>);
                <span class="keyword">if</span> (<span class="negation-char">!</span>costSoFar.<span class="function-name">ContainsKey</span>(<span class="type">next</span>)
                    || newCost &lt; costSoFar[next])
                {
                    costSoFar[next] = newCost;
                    <span class="type">double</span> <span class="variable-name">priority</span> = newCost + <span class="function-name">Heuristic</span>(<span class="type">next</span>, <span class="type">goal</span>);
                    frontier.<span class="function-name">Enqueue</span>(<span class="type">next</span>, <span class="type">priority</span>);
                    cameFrom[next] = current;
                }
            }
        }
    }
}

<span class="keyword">public</span> <span class="keyword">class</span> <span class="type">RunAStar</span>
{
    <span class="keyword">static</span> <span class="type">void</span> <span class="function-name">DrawGrid</span>(<span class="type">SquareGrid</span> <span class="variable-name">grid</span>, <span class="type">AStarSearch</span> <span class="variable-name">astar</span>) {
        <span class="comment-delimiter">// </span><span class="comment">Print out the cameFrom array</span>
        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable-name">y</span> = 0; y &lt; 10; y++)
        {
            <span class="keyword">for</span> (<span class="type">var</span> <span class="variable-name">x</span> = 0; x &lt; 10; x++)
            {
                <span class="type">Location</span> <span class="variable-name">id</span> = <span class="keyword">new</span> <span class="type">Location</span>(<span class="type">x</span>, <span class="type">y</span>);
                <span class="type">Location</span> <span class="variable-name">ptr</span> = id;
                <span class="keyword">if</span> (<span class="negation-char">!</span>astar.cameFrom.<span class="function-name">TryGetValue</span>(<span class="type">id</span>, <span class="keyword">out</span> <span class="type">ptr</span>))
                {
                    ptr = id;
                }
                <span class="keyword">if</span> (grid.walls.<span class="function-name">Contains</span>(<span class="type">id</span>)) { Console.<span class="function-name">Write</span>(<span class="string">"##"</span>); }
                <span class="keyword">else</span> <span class="keyword">if</span> (ptr.x == x+1) { Console.<span class="function-name">Write</span>(<span class="string">"\u2192 "</span>); }
                <span class="keyword">else</span> <span class="keyword">if</span> (ptr.x == x-1) { Console.<span class="function-name">Write</span>(<span class="string">"\u2190 "</span>); }
                <span class="keyword">else</span> <span class="keyword">if</span> (ptr.y == y+1) { Console.<span class="function-name">Write</span>(<span class="string">"\u2193 "</span>); }
                <span class="keyword">else</span> <span class="keyword">if</span> (ptr.y == y-1) { Console.<span class="function-name">Write</span>(<span class="string">"\u2191 "</span>); }
                <span class="keyword">else</span> { Console.<span class="function-name">Write</span>(<span class="string">"* "</span>); }
            }
            Console.<span class="function-name">WriteLine</span>();
        }
    }
    
    <span class="keyword">static</span> <span class="type">void</span> <span class="function-name">Main</span>()
    {
        <span class="comment-delimiter">// </span><span class="comment">Make "diagram 4" from main article</span>
        <span class="type">var</span> <span class="variable-name">grid</span> = <span class="keyword">new</span> <span class="type">SquareGrid</span>(10, 10);
        <span class="keyword">for</span> (<span class="type">var</span> <span class="variable-name">x</span> = 1; x &lt; 4; x++)
        {
            <span class="keyword">for</span> (<span class="type">var</span> <span class="variable-name">y</span> = 7; y &lt; 9; y++)
            {
                grid.walls.<span class="function-name">Add</span>(<span class="keyword">new</span> <span class="type">Location</span>(<span class="type">x</span>, <span class="type">y</span>));
            }
        }
        grid.forests = <span class="keyword">new</span> <span class="type">HashSet</span>&lt;<span class="type">Location</span>&gt;
            {
                <span class="keyword">new</span> <span class="type">Location</span>(3, 4), <span class="keyword">new</span> <span class="type">Location</span>(3, 5),
                <span class="keyword">new</span> <span class="type">Location</span>(4, 1), <span class="keyword">new</span> <span class="type">Location</span>(4, 2),
                <span class="keyword">new</span> <span class="type">Location</span>(4, 3), <span class="keyword">new</span> <span class="type">Location</span>(4, 4),
                <span class="keyword">new</span> <span class="type">Location</span>(4, 5), <span class="keyword">new</span> <span class="type">Location</span>(4, 6),
                <span class="keyword">new</span> <span class="type">Location</span>(4, 7), <span class="keyword">new</span> <span class="type">Location</span>(4, 8),
                <span class="keyword">new</span> <span class="type">Location</span>(5, 1), <span class="keyword">new</span> <span class="type">Location</span>(5, 2),
                <span class="keyword">new</span> <span class="type">Location</span>(5, 3), <span class="keyword">new</span> <span class="type">Location</span>(5, 4),
                <span class="keyword">new</span> <span class="type">Location</span>(5, 5), <span class="keyword">new</span> <span class="type">Location</span>(5, 6),
                <span class="keyword">new</span> <span class="type">Location</span>(5, 7), <span class="keyword">new</span> <span class="type">Location</span>(5, 8),
                <span class="keyword">new</span> <span class="type">Location</span>(6, 2), <span class="keyword">new</span> <span class="type">Location</span>(6, 3),
                <span class="keyword">new</span> <span class="type">Location</span>(6, 4), <span class="keyword">new</span> <span class="type">Location</span>(6, 5),
                <span class="keyword">new</span> <span class="type">Location</span>(6, 6), <span class="keyword">new</span> <span class="type">Location</span>(6, 7),
                <span class="keyword">new</span> <span class="type">Location</span>(7, 3), <span class="keyword">new</span> <span class="type">Location</span>(7, 4),
                <span class="keyword">new</span> <span class="type">Location</span>(7, 5)
            };

        <span class="comment-delimiter">// </span><span class="comment">Run A*</span>
        <span class="type">var</span> <span class="variable-name">astar</span> = <span class="keyword">new</span> <span class="type">AStarSearch</span>(<span class="type">grid</span>, <span class="keyword">new</span> <span class="type">Location</span>(1, 4),
                                    <span class="keyword">new</span> <span class="type">Location</span>(8, 5));

        <span class="function-name">DrawGrid</span>(<span class="type">grid</span>, <span class="type">astar</span>);
    }
}
</pre></div>
<p>I haven’t worked with C# much but the structure of the code is the same for my Python and C++ examples, and you can use that same structure in C#.</p></section><section><h2 id="algorithm">
<span class="section-number"> 4  </span><span><a href="#algorithm"> Algorithm changes</a></span><a class="anchor" href="#algorithm">#</a>
</h2>
<p>The version of Dijkstra’s Algorithm and A* on my pages is slightly different from what you’ll see in an algorithms or AI textbook.</p>
<p>The pure version of Dijkstra’s Algorithm starts the priority queue with all nodes, and does not have early exit. It uses a “decrease-key” operation in the queue. It’s fine in theory. But in practice…</p>
<ol class="org-ol">
<li>By starting the priority with only the start node, we can keep it small, which makes it faster and use less memory.</li>
<li>With early exit, we almost never need to insert all the nodes into the queue, and we can return the path as soon as it’s found.</li>
<li>By not putting all nodes into the queue at the start, most of the time we can use a cheap insert operation instead of the more expensive decrease-key operation.</li>
<li>By not putting all nodes into the queue at the start, we can handle situations where we do not even know all the nodes, or where the number of nodes is infinite.</li>
</ol>
<p>This variant is sometimes called “Uniform Cost Search”. See <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Practical_optimizations_and_infinite_graphs">Wikipedia</a><sup class="print-endnote">[6]</sup> to see the pseudocode, or read <a href="https://www.aaai.org/ocs/index.php/SOCS/SOCS11/paper/viewFile/4017/4357">Felner’s paper</a><sup class="print-endnote">[7]</sup> [PDF] to see justifications for these changes.</p>
<p>There are three further differences between my version and what you might find elsewhere. These apply to both Dijkstra’s Algorithm and A*:</p>
<ol class="org-ol">
<li value="5">I eliminate the check for a node being in the frontier with a higher cost. By not checking, I end up with duplicate elements in the frontier. <em>The algorithm still works.</em> It will revisit some locations more than necessary (but rarely, in my experience, as long as the heuristic is admissible). The code is simpler and it allows me to use a simpler and faster priority queue that does not support the decrease-key operation. The paper <a href="https://www3.cs.stonybrook.edu/~rezaul/papers/TR-07-54.pdf">“Priority Queues and Dijkstra’s Algorithm”</a><sup class="print-endnote">[8]</sup> suggests that this approach is faster in practice.</li>
<li>Instead of storing both a “closed set” and an “open set”, I have call the open set the <code>frontier</code>, and I have a <code>reached</code> flag that tells me whether it’s in <em>either</em> of those sets. I still have two sets but merging the two into <code>reached</code> simplifies the code.</li>
<li>I use hash tables instead of arrays of node objects. This eliminates the rather expensive <em>initialize</em> step that many other implementations have. For large maps, the initialization of those arrays is often slower than the rest of A*.</li>
</ol>
<p>If you have more suggestions for simplifications that preserve performance, please let me know!</p></section><section><h2 id="optimizations">
<span class="section-number"> 5  </span><span><a href="#optimizations"> Optimizations</a></span><a class="anchor" href="#optimizations">#</a>
</h2>
<p>For the code I present here, I’ve been focusing on simplicity and generality rather than performance. <strong>First make it work, then make it fast.</strong> Many of the optimizations I use in real projects are specific to the project, so instead of presenting optimal code, here are some ideas to pursue for your own project:</p>
<h3 id="optimize-graph">
<span class="section-number"> 5.1 </span><span>Graph</span><a class="anchor" aria-hidden="true" href="#optimize-graph">#</a>
</h3>
<p>The biggest optimization you can make is to explore fewer nodes. My #1 recommendation is that if you’re using a grid map, <a href="../grids/algorithms.html">consider using a non-grid</a> pathfinding graph. It’s not always feasible but it’s worth looking at.</p>
<p>If your graph has a simple structure (e.g. a grid), calculate the neighbors in a function. If it’s a more complex structure (either a non-grid, or a grid with lots of walls, like a maze), store the neighbors in a data structure.</p>
<p>You can also save a bit of copying by reusing the neighbors array. Instead of <em>returning</em> a new one each time, allocate it once in the search code and pass it into the graph’s neighbors method.</p>
<h3 id="optimize-bfs-queue">
<span class="section-number"> 5.2 </span><span>Queue</span><a class="anchor" aria-hidden="true" href="#optimize-bfs-queue">#</a>
</h3>
<p>Breadth First Search uses a simple queue instead of the priority queue needed by the other algorithms. Queues are simpler and faster than priority queues. In exchange, the other algorithms usually explore fewer nodes. In most game maps, exploring fewer nodes is worth the slowdown from the other algorithms. There are some maps though where you don’t save much, and it might be better to use Breadth First Search.</p>
<p>For queues, use a deque instead of an array. A deque allows fast insertion and removal on either end, whereas an array is fast only at one end. In Python, see <a href="https://docs.python.org/3/library/collections.html">collections.deque</a><sup class="print-endnote">[9]</sup>; in C++, see the <a href="https://en.cppreference.com/w/cpp/container/deque">deque</a><sup class="print-endnote">[10]</sup> container.</p>
<p>However, it turns out breadth first search doesn’t even need a queue! The queue only contains nodes with distance <code>d</code> and nodes with distance <code>d+1</code>. We can split the queue into two, one for <code>d</code> and one for <code>d+1</code>:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>

<span class="keyword">def</span> <span class="function-name">breadth_first_search</span>(graph: Graph, start: Location):
    <span class="variable-name">currentfrontier</span> <span class="operator">=</span> []
    <span class="variable-name">nextfrontier</span> <span class="operator">=</span> []
    currentfrontier.append(start)
    <span class="variable-name">reached</span>: <span class="builtin">dict</span>[<span class="type">Location</span>, <span class="builtin">bool</span>] <span class="operator">=</span> {}
    <span class="variable-name">reached</span>[start] <span class="operator">=</span> <span class="constant">True</span>
    
    <span class="keyword">while</span> currentfrontier:
        <span class="keyword">for</span> current <span class="keyword">in</span> currentfrontier:
            <span class="keyword">for</span> <span class="builtin">next</span> <span class="keyword">in</span> graph.neighbors(current):
                <span class="keyword">if</span> <span class="builtin">next</span> <span class="keyword">not</span> <span class="keyword">in</span> reached:
                    nextfrontier.append(<span class="builtin">next</span>)
                    <span class="variable-name">reached</span>[<span class="builtin">next</span>] <span class="operator">=</span> <span class="constant">True</span>

        <span class="comment-delimiter"># </span><span class="comment">optimization: swap and clear</span>
        <span class="variable-name">currentfrontier</span>, <span class="variable-name">nextfrontier</span> <span class="operator">=</span> nextfrontier, currentfrontier
        nextfrontier.clear()

<span class="builtin">print</span>(<span class="string">'Reachable from A:'</span>)
breadth_first_search(example_graph, <span class="string">'A'</span>)
<span class="builtin">print</span>(<span class="string">'Reachable from E:'</span>)
breadth_first_search(example_graph, <span class="string">'E'</span>)
</pre></div>
<p>This uses two arrays instead of a queue, making Breadth First Search run faster than Dijkstra’s Algorithm when you don’t have varying edge weights. In my Javascript projects, it runs at over 1,000,000 nodes per second.</p>
<h3 id="optimize-queue">
<span class="section-number"> 5.3 </span><span>Priority Queue</span><a class="anchor" aria-hidden="true" href="#optimize-queue">#</a>
</h3>
<p>For priority queues, use a binary heap instead of an array or sorted array. A binary heap allows fast insertion and removal, whereas an array is fast at one or the other but not both. In Python, see <a href="https://docs.python.org/2/library/heapq.html">heapq</a><sup class="print-endnote">[11]</sup>; in C++, see the <a href="https://en.cppreference.com/w/cpp/container/priority_queue">priority_queue</a><sup class="print-endnote">[12]</sup> container.</p>
<p>In Python, the Queue and PriorityQueue classes I presented above are so simple that you might consider inlining the methods into the search algorithm. I don’t know if this buys you much; I need to measure it. The C++ versions are going to be inlined.</p>
<p>In Dijkstra’s Algorithm, note that the priority queue’s priority is stored twice, once in the priority queue and once in <code>cost_so_far</code>, so you could write a priority queue that gets priorities from elsewhere. I’m not sure if it’s worth it.</p>
<p>The paper <a href="https://www3.cs.stonybrook.edu/~rezaul/papers/TR-07-54.pdf">“Priority Queues and Dijkstra’s Algorithm”</a><sup class="print-endnote">[13]</sup> by Chen, Chowdhury, Ramachandran, Lan Roche, Tong suggests optimizing the structure of Dijkstra’s Algorithm by not reprioritizing, and it also suggests looking at <a href="https://en.wikipedia.org/wiki/Pairing_heap">pairing heaps</a><sup class="print-endnote">[14]</sup> and other data structures.</p>
<p>If you’re considering using something other than a binary heap, first measure the size of your frontier and how often you reprioritize. Profile the code and see if the priority queue is the bottleneck.</p>
<p>My gut feeling is that <em>bucketing</em> is promising. Just as bucket sort and radix sort can be useful alternatives to quicksort when the keys are integers, we have an even better situation with Dijkstra’s Algorithm and A*. The priorities in Dijkstra’s Algorithm are <em>incredibly narrow</em>. If the lowest element in the queue has priority <code>f</code>, then the highest element has priority <code>f+e</code> where <code>e</code> is the maximum edge weight. In the forest example, I have edge weights 1 and 5. That means all the priorities in the queue are going to be between <code>f</code> and <code>f+5</code>. Since they’re all integers, <em>there are only six different priorities</em>. We could use six buckets and not sort anything at all! A* produces a wider range of priorities but it’s still worth looking at. And there are fancier bucketing approaches that handle a wider range of situations.</p>
<p><a href="http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#set-representation">I have more note about priority queue data structures here</a><sup class="print-endnote">[15]</sup>.</p>
<h3 id="optimize-search">
<span class="section-number"> 5.4 </span><span>Search</span><a class="anchor" aria-hidden="true" href="#optimize-search">#</a>
</h3>
<p>The heuristic adds complexity and cpu time. The goal though is to explore fewer nodes. In some maps (such as mazes), the heuristic may not add much information, and it may be better to use a simpler algorithm without a heuristic guide.</p>
<p>Some people use an <em>inadmissible</em> (overestimating) heuristic to speed up A* search. This seems reasonable. I haven’t looked closely into its implications though. I believe (but don’t know for sure) that some already-reached elements may need to be visited again even after they’ve been taken out of the frontier.</p>
<p>Some implementations <em>always</em> insert a new node into the open set, even if it’s already there. You can avoid the potentially expensive step of checking whether the node is already in the open set. This will make your open set bigger/slower and you’ll also end up evaluating more nodes than necessary. If the open-set test is expensive, it might still be worth it. However, in the code I’ve presented, I made the test cheap and I don’t use this approach.</p>
<p>Some implementations <em>don’t test</em> whether a new node is better than an existing node in the open set. This avoids a potentially expensive check. However, it also <em>can lead to a bug</em>. For some types of maps, you will not find the shortest path when you skip this test. In the code I’ve presented, I check this (<code>new_cost &lt; cost_so_far</code>). The test is cheap because I made it cheap to look up <code>cost_so_far</code>.</p>
<h3 id="optimize-integer-ids">
<span class="section-number"> 5.5 </span><span>Integer locations</span><a class="anchor" aria-hidden="true" href="#optimize-integer-ids">#</a>
</h3>
<p>If your graph uses integers as locations, consider using a simple array instead of a hash table for <code>cost_so_far</code>, <code>reached</code>, <code>came_from</code>, etc. Since <code>reached</code> is an array of booleans, you can use a bit vector. Initialize the <code>reached</code> bit vector for all ids, but leave <code>cost_so_far</code> and <code>came_from</code> uninitialized. Then only initialize on the first visit.</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="type">vector</span>&lt;<span class="type">uint16_t</span>&gt; <span class="variable-name">reached</span>(1 + maximum_node_id/16);

…
    size_t index = node_id/16;
    <span class="type">uint16_t</span> <span class="variable-name">bitmask</span> = 1u &lt;&lt; (node_id &amp; 0xf);
    <span class="keyword">if</span> (<span class="negation-char">!</span>(reached[index] &amp; bitmask)
        || new_cost &lt; cost_so_far[next]) {
        reached[index] |= bitmask;
        …
    }
</pre></div>
<p>If you run only one search at a time, you can statically allocate and then reuse these arrays from one invocation to the next. Then keep an array of all indices that have been assigned to the bit vector, and then reset those on exit. For example:</p>
<div class="org-src-container"><pre class="src src-cpp"><span class="keyword">static</span> <span class="type">vector</span>&lt;<span class="type">uint16_t</span>&gt; <span class="variable-name">reached</span>(1 + maximum_node_id/16);
<span class="keyword">static</span> <span class="type">vector</span>&lt;<span class="type">size_t</span>&gt; <span class="variable-name">indices_to_clear</span>;
…
    size_t index = node_id/16;
    <span class="type">uint16_t</span> <span class="variable-name">bitmask</span> = 1u &lt;&lt; (node_id &amp; 0xf);
    <span class="keyword">if</span> (<span class="negation-char">!</span>(reached[index] &amp; bitmask)
        || new_cost &lt; cost_so_far[next]) {
        <span class="keyword">if</span> (<span class="negation-char">!</span>reached[index]) {
            indices_to_clear.push_back(index);
        }
        reached[index] |= bitmask;
        …
    }
…

<span class="keyword">for</span> (size_t <span class="type">index</span> : indices_to_clear) {
    reached[index] = 0;
}
indices_to_clear.clear();
</pre></div>
<p>(Caveat: I haven’t used or tested this code)</p></section><section><h2 id="troubleshooting">
<span class="section-number"> 6  </span><span><a href="#troubleshooting"> Troubleshooting</a></span><a class="anchor" href="#troubleshooting">#</a>
</h2>
<h3 id="troubleshooting-wrong-path">
<span class="section-number"> 6.1 </span><span>Wrong paths</span><a class="anchor" aria-hidden="true" href="#troubleshooting-wrong-path">#</a>
</h3>
<p>If you’re not getting a shortest path, try testing:</p>
<ul class="org-ul">
<li>Does your priority queue work correctly? Try stopping the search and dequeuing all the elements. They should all be in order.</li>
<li>Does your heuristic ever overestimate the true distance? The <code>priority</code> of a new node should never be lower than the priority of its parent, unless you are overestimating the distance (you can do this but you won’t get shortest paths anymore). Try setting the heuristic to 0. If a 0 heuristic fixes the paths, your heuristic is probably wrong. If a 0 heuristic doesn’t help, then your graph search algorithm code probably has a bug.</li>
<li>In a statically typed language, the cost, heuristic, and priority values need to have compatible types. The sample code on this page works with either integers or floating point types, but not all graphs and heuristics are limited to integer values. Since priorities are the sum of costs and heuristics, the priorities will need to be floating point if <em>either</em> costs or heuristics are floating point.</li>
<li>The heuristic and costs need to have the same “units”. Try testing A* on a map with no walls. If the heuristic and movement costs match up, the priority should be the <em>same</em> along the entire path. If it isn’t, then your heuristic and costs probably don’t match up. When there are no obstacles and uniform movement costs, at each step, the heuristic should decrease by the same amount cost_so_far increases.</li>
</ul>
<h3 id="troubleshooting-ugly-path">
<span class="section-number"> 6.2 </span><span>Ugly paths</span><a class="anchor" aria-hidden="true" href="#troubleshooting-ugly-path">#</a>
</h3>
<p>The most common question I get when people run pathfinding on a grid is <em>why don’t my paths look straight?</em> On a grid with uniform movement costs, there can be more than one shortest path of the same length. For example, in a 4-way movement grid, moving south 2 and east 2 could be any of these: <code>SSEE</code>, <code>SESE</code>, <code>SEES</code>, <code>ESSE</code>, <code>ESES</code>, <code>EESS</code>. The pathfinding algorithm is going to pick one, and it may not be the one you prefer. The path is <em>short</em> but it doesn’t <em>look</em> good. What can we do to favor good looking paths, like <code>SESE</code> or <code>ESES</code>?</p>
<figure><svg viewBox="-1 0 5 4" width="15%"><g fill="hsl(0,20%,70%)" stroke="white" stroke-width="0.1"><rect x="0" y="0" width="1" height="1"></rect><rect x="0" y="1" width="1" height="1"></rect><rect x="0" y="2" width="1" height="1"></rect><rect x="1" y="2" width="1" height="1"></rect><rect x="2" y="2" width="1" height="1"></rect></g><text text-anchor="middle" x="1.5" y="4" font-size="0.8" font-family="sans-serif">SSEE</text></svg><svg viewBox="-1 0 5 4" width="15%"><g fill="hsl(0,20%,70%)" stroke="white" stroke-width="0.1"><rect x="0" y="0" width="1" height="1"></rect><rect x="0" y="1" width="1" height="1"></rect><rect x="1" y="1" width="1" height="1"></rect><rect x="1" y="2" width="1" height="1"></rect><rect x="2" y="2" width="1" height="1"></rect></g><text text-anchor="middle" x="1.5" y="4" font-size="0.8" font-family="sans-serif">SESE</text></svg><svg viewBox="-1 0 5 4" width="15%"><g fill="hsl(0,20%,70%)" stroke="white" stroke-width="0.1"><rect x="0" y="0" width="1" height="1"></rect><rect x="0" y="1" width="1" height="1"></rect><rect x="1" y="1" width="1" height="1"></rect><rect x="2" y="1" width="1" height="1"></rect><rect x="2" y="2" width="1" height="1"></rect></g><text text-anchor="middle" x="1.5" y="4" font-size="0.8" font-family="sans-serif">SEES</text></svg><svg viewBox="-1 0 5 4" width="15%"><g fill="hsl(0,20%,70%)" stroke="white" stroke-width="0.1"><rect x="0" y="0" width="1" height="1"></rect><rect x="1" y="0" width="1" height="1"></rect><rect x="1" y="1" width="1" height="1"></rect><rect x="1" y="2" width="1" height="1"></rect><rect x="2" y="2" width="1" height="1"></rect></g><text text-anchor="middle" x="1.5" y="4" font-size="0.8" font-family="sans-serif">ESSE</text></svg><svg viewBox="-1 0 5 4" width="15%"><g fill="hsl(0,20%,70%)" stroke="white" stroke-width="0.1"><rect x="0" y="0" width="1" height="1"></rect><rect x="1" y="0" width="1" height="1"></rect><rect x="1" y="1" width="1" height="1"></rect><rect x="2" y="1" width="1" height="1"></rect><rect x="2" y="2" width="1" height="1"></rect></g><text text-anchor="middle" x="1.5" y="4" font-size="0.8" font-family="sans-serif">ESES</text></svg><svg viewBox="-1 0 5 4" width="15%"><g fill="hsl(0,20%,70%)" stroke="white" stroke-width="0.1"><rect x="0" y="0" width="1" height="1"></rect><rect x="1" y="0" width="1" height="1"></rect><rect x="2" y="0" width="1" height="1"></rect><rect x="2" y="1" width="1" height="1"></rect><rect x="2" y="2" width="1" height="1"></rect></g><text text-anchor="middle" x="1.5" y="4" font-size="0.8" font-family="sans-serif">EESS</text></svg><figcaption>Many ways to move south 2 east 2</figcaption></figure><ul class="org-ul">
<li>
<em>Don’t use a grid</em>: tell A* only the places where you might turn, instead of every grid square; <a href="../grids/algorithms.html">read more here</a>. Bonus: switching to a non-grid usually makes A* much faster.</li>
<li>
<em>Modify the A* algorithm</em> to support “any angle” paths: Theta*, Block A*, Field A*, or AnyA. See the paper <a href="https://scholar.google.com/scholar?cluster=8491292501067866547&amp;hl=en&amp;as_sdt=0,5">An Empirical Comparison of Any-Angle Path-Planning Algorithms</a><sup class="print-endnote">[16]</sup> from Uras &amp; Koenig.</li>
<li>
<em>Choose</em> the paths by calculating some metric that lets you pick the most pleasing path. See <a href="https://towardsdatascience.com/a-short-and-direct-walk-with-pascals-triangle-26a86d76f75f">Path Counting for Grid-Based Navigation</a><sup class="print-endnote">[17]</sup> (and <a href="https://www.keanw.com/2022/06/a-paper-on-our-space-analysis-algorithm-in-the-journal-of-artificial-intelligence-research.html">blog post</a><sup class="print-endnote">[18]</sup>) for a clever way to do this using Pascal’s Triangle.</li>
<li>
<em>Straighten</em> the paths using a “string pulling” algorithm: If the final path has points P, Q, R, S, and there’s a straight line from P to S, then follow that straight line instead of visiting Q and R.</li>
<li>
<em>Nudge</em> the paths when there’s a tie towards better-looking paths, by adjusting the order of nodes in the queue. For 4-way movement I describe two hacks below. For 8-way movement, make sure your neighbors function returns the cardinal directions (N, E, S, W) earlier in the array than the diagonal directions (NW, SE, SW, NE).</li>
</ul>
<p>The hacks don’t work as well as the other three approaches but they’re easy to implement, so I’ll describe them here:</p>
<h4 id="ties-checkerboard-neighbors">
<span><span class="section-number-4">6.2.1.</span> Checkerboard neighbor order</span><a class="anchor" aria-hidden="true" href="#ties-checkerboard-neighbors">#</a>
</h4>
<p>Breadth First Search is sensitive to the order in which it explores the neighbors of a tile. We normally go through the neighbors in a fixed order. Since Breadth First Search uses a first-in-first-out queue, it will pick the <em>first</em> path to a node.</p>
<p>If moving south 2 and east 2, there are many ways to get there: <code>SSEE</code>, <code>SESE</code>, <code>SEES</code>, <code>ESSE</code>, <code>ESES</code>, <code>EESS</code>. If East comes before South in the list of neighbors, then it will <em>always</em> explore east before it explores south, and end up choosing <code>EESS</code>. If South comes before East, then it will always explore south first, and end up choosing <code>SSEE</code>. We can see that problem in this larger example where the order is East, North, West, South:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>
test_with_custom_order([(<span class="operator">+</span>1, 0), (0, <span class="operator">-</span>1), (<span class="operator">-</span>1, 0), (0, <span class="operator">+</span>1)])
</pre></div>
<pre class="example" id="org6a426a9">__________________________________________________________________________________________
 &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  v  v ###### .  .  .  .  .  .  . 
 &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  v  v ###### .  .  .  v  .  .  . 
 &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  v  v ###### .  .  &gt;  v  Z  v  . 
 ^  ^  ^ ###### &gt;  &gt;  &gt;  v  v  v  v  @  @  @  @  @  @  @  @  @ ###### .  &gt;  &gt;  v  @  v  v 
 ^  ^  ^ ###### &gt;  &gt;  &gt;  v  v  v  v  @ ###### ^  ^  ^  ^  ^  @ ###### &gt;  &gt;  &gt;  v  @  v  v 
 ^  ^  ^ ###### &gt;  &gt;  &gt;  v  v  v  v  @ ###### ^  ^  ^  ^  ^  @ ############### v  @  v  v 
 ^  ^  ^ ###### &gt;  &gt;  &gt;  v  v  v  v  @ ###### ^  ^  ^  ^  ^  @ ############### v  @  v  v 
 ^  ^  ^ ###### &gt;  &gt;  &gt;  A  @  @  @  @ ###### ^  ^  ^  ^  ^  @  @  @  @  @  @  @  @  &lt;  &lt; 
 &gt;  &gt;  v ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ 
 &gt;  &gt;  v ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ 
 &gt;  &gt;  v ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ 
 &gt;  &gt;  v ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ 
 &gt;  &gt;  &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  . 
 ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  .  .  . 
 ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>It moves east as far as possible before considering north or south.</p>
<p>What if North came in the list before East? Here’s the output with the order South, West, North, East:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>
test_with_custom_order([(0, <span class="operator">+</span>1), (<span class="operator">-</span>1, 0), (0, <span class="operator">-</span>1), (<span class="operator">+</span>1, 0)])
</pre></div>
<pre class="example" id="org906f1bf">__________________________________________________________________________________________
 v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; ###### .  .  .  v  .  .  . 
 v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; ###### .  .  v  v  &lt;  .  . 
 &gt;  &gt;  &gt;  &gt;  &gt;  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; ###### .  v  v  @  Z  .  . 
 &gt;  &gt;  ^ ###### v  v  v  @  @  @  @  @  @  @  @  &lt;  &lt;  &lt;  &lt;  &lt; ###### v  v  v  @  &lt;  &lt;  . 
 &gt;  &gt;  ^ ###### v  v  v  @  &lt;  &lt;  &lt;  &lt; ###### @  &lt;  &lt;  &lt;  &lt;  &lt; ###### &gt;  &gt;  &gt;  @  &lt;  &lt;  &lt; 
 &gt;  &gt;  ^ ###### v  v  v  @  &lt;  &lt;  &lt;  &lt; ###### @  &lt;  &lt;  &lt;  &lt;  &lt; ############### @  &lt;  &lt;  &lt; 
 &gt;  &gt;  ^ ###### v  v  v  @  &lt;  &lt;  &lt;  &lt; ###### @  &lt;  &lt;  &lt;  &lt;  &lt; ############### @  &lt;  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  &gt;  A  &lt;  &lt;  &lt;  &lt; ###### @  @  @  @  @  @  @  @  @  @  @  @  &lt;  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  . 
 &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  .  . 
 &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>Let’s try South, East, West, North:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>
test_with_custom_order([(0, <span class="operator">+</span>1), (<span class="operator">+</span>1, 0), (<span class="operator">-</span>1, 0), (0, <span class="operator">-</span>1)])
</pre></div>
<pre class="example" id="org3722d61">__________________________________________________________________________________________
 v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v ###### .  .  .  .  .  .  . 
 v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v ###### .  .  .  v  .  .  . 
 &gt;  &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v ###### .  .  v  v  Z  v  . 
 &gt;  &gt;  ^ ###### v  v  v  v  v  v  v  @  @  @  @  &lt;  &lt;  &lt;  &lt;  &lt; ###### .  v  v  v  @  v  v 
 &gt;  &gt;  ^ ###### v  v  v  v  v  v  v  @ ###### @  &lt;  &lt;  &lt;  &lt;  &lt; ###### &gt;  &gt;  &gt;  v  @  v  v 
 &gt;  &gt;  ^ ###### v  v  v  v  v  v  v  @ ###### @  &lt;  &lt;  &lt;  &lt;  &lt; ############### v  @  v  v 
 &gt;  &gt;  ^ ###### v  v  v  v  v  v  v  @ ###### @  &lt;  &lt;  &lt;  &lt;  &lt; ############### v  @  v  v 
 v  v  v ###### &gt;  &gt;  &gt;  A  @  @  @  @ ###### @  @  @  @  @  @  @  @  @  @  @  @  @  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  . 
 &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  .  . 
 &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  &gt;  ^  &lt;  &lt;  &lt;  &lt; ###### ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>No help. <em>Any</em> fixed order of neighbors will lead to long horizontal and vertical sections of the path.</p>
<p><strong>Here’s the hack</strong> for Breadth First Search: in the graph class, make the list of neighbors depend on <code>(x + y) % 2</code>:</p>
<ul class="org-ul">
<li>when 0: return the South, North, West, East neighbors</li>
<li>when 1: return the East, West, North, South neighbors</li>
</ul>
<p>The result is the path alternating between vertical and horizontal steps:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>
test_with_custom_order(<span class="constant">None</span>)
</pre></div>
<pre class="example" id="orgb97f068">__________________________________________________________________________________________
 &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt; ###### .  .  .  .  .  .  . 
 &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; ###### .  .  .  v  .  .  . 
 &gt;  &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; ###### .  .  v  v  Z  v  . 
 &gt;  &gt;  ^ ###### v  v  v  v  v  v  v  @  @  @  @  &lt;  &lt;  &lt;  &lt;  &lt; ###### .  &gt;  &gt;  v  @  v  v 
 &gt;  ^  ^ ###### v  v  v  v  v  v  @  @ ###### @  @  &lt;  &lt;  &lt;  &lt; ###### &gt;  &gt;  &gt;  v  @  v  v 
 ^  ^  ^ ###### &gt;  v  v  v  v  @  @  &lt; ###### ^  @  @  &lt;  &lt;  &lt; ############### v  @  v  &lt; 
 ^  ^  ^ ###### &gt;  &gt;  v  v  @  @  &lt;  &lt; ###### ^  ^  @  @  &lt;  &lt; ############### v  @  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  &gt;  A  @  &lt;  &lt;  &lt; ###### ^  ^  ^  @  @  @  @  @  @  @  @  @  @  &lt;  &lt; 
 v  v  v ###### &gt;  &gt;  ^  ^  ^  &lt;  &lt;  &lt; ###### ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 v  v  v ###### &gt;  ^  ^  ^  ^  ^  &lt;  &lt; ###### ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  v  v ###### ^  ^  ^  ^  ^  ^  ^  &lt; ###### ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  &gt;  v ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; 
 &gt;  &gt;  &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  &lt;  &lt;  . 
 &gt;  &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  &lt;  &lt;  &lt;  .  . 
 &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  &lt;  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>Here’s the code:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">class</span> <span class="type">SquareGrid</span>:
    …
    <span class="keyword">def</span> <span class="function-name">neighbors</span>(<span class="keyword">self</span>, <span class="builtin">id</span>: GridLocation) <span class="operator">-&gt;</span> Iterator[GridLocation]:
        (<span class="variable-name">x</span>, <span class="variable-name">y</span>) <span class="operator">=</span> <span class="builtin">id</span>
        <span class="variable-name">neighbors</span> <span class="operator">=</span> [(x<span class="operator">+</span>1, y), (x<span class="operator">-</span>1, y), (x, y<span class="operator">-</span>1), (x, y<span class="operator">+</span>1)] <span class="comment-delimiter"># </span><span class="comment">E W N S</span>
        <span class="keyword">if</span> (x <span class="operator">+</span> y) <span class="operator">%</span> 2 <span class="operator">==</span> 0: neighbors.reverse() <span class="comment-delimiter"># </span><span class="comment">change to S N W E</span>
        <span class="variable-name">results</span> <span class="operator">=</span> <span class="builtin">filter</span>(<span class="keyword">self</span>.in_bounds, neighbors)
        <span class="variable-name">results</span> <span class="operator">=</span> <span class="builtin">filter</span>(<span class="keyword">self</span>.passable, results)
        <span class="keyword">return</span> results
</pre></div>
<p>This is a quick hack but it works with 4-way movement to make Breadth First Search paths look better. <strong>I used this hack on these tutorial pages</strong>. (Note: I came up with this hack for these tutorial pages; if you’ve seen a good reference please send it to me.)</p>
<h4 id="ties-checkerboard-costs">
<span><span class="section-number-4">6.2.2.</span> Checkerboard movement costs</span><a class="anchor" aria-hidden="true" href="#ties-checkerboard-costs">#</a>
</h4>
<p>The direction order hack above works with Breadth First Search, but does it work with A*? Let’s try:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>

<span class="variable-name">g</span> <span class="operator">=</span> GridWithWeights(30, 15)
g.<span class="variable-name">walls</span> <span class="operator">=</span> DIAGRAM1_WALLS
<span class="variable-name">start</span>, <span class="variable-name">goal</span> <span class="operator">=</span> (8, 7), (27, 2)
<span class="variable-name">came_from</span>, <span class="variable-name">cost_so_far</span> <span class="operator">=</span> a_star_search(g, start, goal)
draw_grid(g, point_to<span class="operator">=</span>came_from, path<span class="operator">=</span>reconstruct_path(came_from, start, goal), start<span class="operator">=</span>start, goal<span class="operator">=</span>goal)
</pre></div>
<pre class="example" id="org1993dec">__________________________________________________________________________________________
 .  .  .  .  .  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v ###### .  .  .  .  .  .  . 
 .  .  .  .  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v ###### .  .  .  v  .  .  . 
 .  .  .  &gt;  &gt;  &gt;  &gt;  &gt;  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; ###### .  .  &gt;  @  Z  .  . 
 .  .  . ###### &gt;  &gt;  &gt;  @  @  @  @  @  @  @  @  @  @  @  @  @ ###### .  .  &gt;  @  &lt;  .  . 
 .  .  . ###### &gt;  &gt;  &gt;  @  &lt;  &lt;  &lt;  &lt; ###### ^  ^  ^  ^  ^  @ ###### .  .  &gt;  @  &lt;  .  . 
 .  .  . ###### &gt;  &gt;  &gt;  @  &lt;  &lt;  &lt;  &lt; ###### ^  ^  ^  ^  ^  @ ############### @  &lt;  .  . 
 .  .  . ###### &gt;  &gt;  &gt;  @  &lt;  &lt;  &lt;  &lt; ###### ^  ^  ^  ^  ^  @ ############### @  &lt;  .  . 
 .  .  . ###### &gt;  &gt;  &gt;  A  &lt;  &lt;  &lt;  &lt; ###### ^  ^  ^  ^  ^  @  @  @  @  @  @  @  &lt;  .  . 
 .  .  . ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  .  .  . 
 .  .  . ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### .  ^  ^  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### .  .  ^  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>No, it doesn’t. It changes the <em>insertion</em> order for the queue, but Dijkstra’s Algorithm and A* use a <em>priority</em> queue that follows priority order instead of the insertion order. The priority in Dijkstra’s Algorithm uses the movement cost; the priority in A* uses both the movement cost and the heuristic. We need to modify either the movement cost or the heuristic to change the priority order.</p>
<p><strong>Here’s the hack</strong> for A* and Dijkstra’s Algorithm: in the graph class, make the movement cost depend on <code>(x + y) % 2</code>:</p>
<ul class="org-ul">
<li>when 0: make horizontal movement slightly more expensive</li>
<li>when 1: make vertical movement slightly more expensive</li>
</ul>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>

<span class="variable-name">g</span> <span class="operator">=</span> GridWithAdjustedWeights(30, 15)
g.<span class="variable-name">walls</span> <span class="operator">=</span> DIAGRAM1_WALLS
<span class="variable-name">start</span>, <span class="variable-name">goal</span> <span class="operator">=</span> (8, 7), (27, 2)
<span class="variable-name">came_from</span>, <span class="variable-name">cost_so_far</span> <span class="operator">=</span> a_star_search(g, start, goal)
draw_grid(g, point_to<span class="operator">=</span>came_from, path<span class="operator">=</span>reconstruct_path(came_from, start, goal), start<span class="operator">=</span>start, goal<span class="operator">=</span>goal)
</pre></div>
<pre class="example" id="org5976fb4">__________________________________________________________________________________________
 .  .  .  .  .  v  v  v  v  v  v  v  v  v  v  v  &lt;  v  &lt;  v  &lt; ###### .  .  .  .  .  .  . 
 .  .  .  .  v  v  v  v  v  v  v  v  v  v  v  &lt;  v  &lt;  v  &lt;  v ###### .  .  .  .  .  .  . 
 .  .  .  &gt;  &gt;  v  &gt;  v  v  v  v  v  v  v  &lt;  &lt;  &lt;  &lt;  &lt;  &lt;  &lt; ###### .  .  .  v  Z  .  . 
 .  .  . ###### &gt;  v  v  v  v  v  v  @  @  @  @  @  @  &lt;  &lt;  &lt; ###### .  .  &gt;  v  @  &lt;  . 
 .  .  . ###### v  &gt;  v  v  v  v  @  @ ###### ^  &lt;  @  @  ^  &lt; ###### .  .  &gt;  v  @  &lt;  . 
 .  .  . ###### &gt;  v  &gt;  v  v  @  @  &lt; ###### ^  ^  &lt;  @  @  ^ ############### v  @  &lt;  . 
 .  .  . ###### &gt;  &gt;  v  v  @  @  &lt;  &lt; ###### ^  ^  ^  &lt;  @  @ ############### v  @  &lt;  . 
 .  .  . ###### &gt;  &gt;  &gt;  A  @  &lt;  &lt;  &lt; ###### ^  ^  ^  ^  &lt;  @  @  @  @  @  @  @  @  &lt;  . 
 .  .  . ###### &gt;  &gt;  ^  ^  ^  &lt;  ^  &lt; ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  .  . 
 .  .  . ###### &gt;  ^  ^  ^  ^  ^  &lt;  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### .  ^  ^  ^  ^  ^  ^  &lt; ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  . ###### .  .  ^  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  ^  ^  ^  ^  ^ ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
 .  .  .  .  .  .  .  .  .  .  .  .  . ###### .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>This works nicely with 4-way movement.</p>
<p>Here’s the code:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">class</span> <span class="type">GridWithAdjustedWeights</span>(GridWithWeights):
    <span class="keyword">def</span> <span class="function-name">cost</span>(<span class="keyword">self</span>, from_node, to_node):
        <span class="variable-name">prev_cost</span> <span class="operator">=</span> <span class="builtin">super</span>().cost(from_node, to_node)
        <span class="variable-name">nudge</span> <span class="operator">=</span> 0
        (<span class="variable-name">x1</span>, <span class="variable-name">y1</span>) <span class="operator">=</span> from_node
        (<span class="variable-name">x2</span>, <span class="variable-name">y2</span>) <span class="operator">=</span> to_node
        <span class="keyword">if</span> (x1 <span class="operator">+</span> y1) <span class="operator">%</span> 2 <span class="operator">==</span> 0 <span class="keyword">and</span> x2 <span class="operator">!=</span> <span class="variable-name">x1</span>: <span class="type">nudge</span> <span class="operator">=</span> 1
        <span class="keyword">if</span> (x1 <span class="operator">+</span> y1) <span class="operator">%</span> 2 <span class="operator">==</span> 1 <span class="keyword">and</span> y2 <span class="operator">!=</span> <span class="variable-name">y1</span>: <span class="type">nudge</span> <span class="operator">=</span> 1
        <span class="keyword">return</span> prev_cost <span class="operator">+</span> 0.001 <span class="operator">*</span> nudge
</pre></div>
<p>This is a quick hack but it works with 4-way movement to make Dijkstra’s Algorithm and A* paths look better. (Note: I came up with this hack for these tutorial pages; if you’ve seen this idea elsewhere please send me a reference so I can add it to the page.)</p>
<h4 id="ties-diagonals">
<span><span class="section-number-4">6.2.3.</span> 8-way movement</span><a class="anchor" aria-hidden="true" href="#ties-diagonals">#</a>
</h4>
<p>The above two hacks work for 4-way movement. What if you have 8-way movement? If all 8 directions have the same movement cost, we can end up with a path that takes diagonals when it seems like it shouldn’t:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>
test_with_custom_order([(<span class="operator">-</span>1, <span class="operator">-</span>1), (<span class="operator">-</span>1, <span class="operator">+</span>1), (<span class="operator">+</span>1, <span class="operator">-</span>1), (<span class="operator">+</span>1, <span class="operator">+</span>1), (<span class="operator">+</span>1, 0), (0, <span class="operator">-</span>1), (<span class="operator">-</span>1, 0), (0, <span class="operator">+</span>1)])
</pre></div>
<pre class="example" id="org5a34154">__________________________________________________________________________________________
 v  &gt;  v  v  v  v  v  v  v  v  v  v  v  v  v  v  &lt;  v  &lt;  v  &lt; ###### .  .  .  .  .  .  . 
 &gt;  ^  &gt;  v  v  v  v  v  v  v  v  v  v  v  @  &lt;  ^  &lt;  ^  &lt;  ^ ###### v  v  v  v  v  v  v 
 ^  &gt;  ^  &gt;  v  v  v  v  v  v  v  v  v  @  &lt;  @  &lt;  ^  &lt;  ^  &lt; ###### v  v  v  v  Z  v  v 
 &gt;  ^  ^ ###### v  v  v  v  v  v  v  @  &lt;  ^  &lt;  @  &lt;  ^  &lt;  ^ ###### &gt;  v  v  v  @  v  v 
 ^  ^  ^ ###### v  v  v  v  v  v  @  &lt; ###### ^  &lt;  @  &lt;  ^  &lt; ###### ^  &gt;  v  @  v  v  v 
 ^  ^  ^ ###### &gt;  v  v  v  v  @  &lt;  ^ ###### ^  ^  &lt;  @  &lt;  ^ ############### v  @  v  &lt; 
 ^  ^  ^ ###### ^  &gt;  v  v  @  &lt;  ^  &lt; ###### ^  ^  ^  &lt;  @  &lt; ############### @  v  &lt;  ^ 
 ^  ^  ^ ###### &gt;  ^  &gt;  A  &lt;  ^  &lt;  ^ ###### ^  ^  ^  ^  &lt;  @  &lt;  @  &lt;  @  @  v  &lt;  ^  &lt; 
 v  v  v ###### ^  &gt;  ^  ^  ^  &lt;  ^  &lt; ###### ^  ^  ^  ^  ^  &lt;  @  &lt;  @  &lt;  ^  &lt;  ^  &lt;  ^ 
 v  v  v ###### &gt;  ^  ^  ^  ^  ^  &lt;  ^ ###### ^  ^  ^  ^  ^  ^  &lt;  ^  &lt;  ^  &lt;  ^  &lt;  ^  &lt; 
 v  v  v ###### ^  ^  ^  ^  ^  ^  ^  &lt; ###### ^  ^  ^  ^  ^  ^  ^  &lt;  ^  &lt;  ^  &lt;  ^  &lt;  ^ 
 &gt;  v  v ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  &lt;  ^  &lt;  ^  &lt;  ^  &lt; 
 ^  &gt;  v  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  &lt;  ^  &lt;  ^  &lt;  ^ 
 &gt;  ^  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  &lt;  ^  &lt;  ^  &lt; 
 ^  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  &lt;  ^  &lt;  ^ 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>The 4-way tie-breaking hacks can be extended to work here:</p>
<ul class="org-ul">
<li>Breadth First Search: make sure the cardinal neighbors (N, S, E, W) come before the diagonal neighbors (NE, NW, SE, SW).</li>
<li>Dijkstra’s Algorthm, A*: add a tiny movement penalty (0.001) to diagonal movements.</li>
</ul>
<p>After using one of these hacks, the path will look like this:</p>
<div class="org-src-container"><pre class="src src-python"><span class="keyword">from</span> implementation <span class="keyword">import</span> <span class="operator">*</span>
test_with_custom_order([(<span class="operator">+</span>1, 0), (0, <span class="operator">-</span>1), (<span class="operator">-</span>1, 0), (0, <span class="operator">+</span>1), (<span class="operator">-</span>1, <span class="operator">-</span>1), (<span class="operator">-</span>1, <span class="operator">+</span>1), (<span class="operator">+</span>1, <span class="operator">-</span>1), (<span class="operator">+</span>1, <span class="operator">+</span>1)])
</pre></div>
<pre class="example" id="org3df58f1">__________________________________________________________________________________________
 v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v ###### .  .  .  .  .  .  . 
 v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v ###### .  v  v  v  v  .  . 
 &gt;  &gt;  &gt;  &gt;  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v  v ###### v  v  v  v  Z  v  v 
 ^  ^  ^ ###### v  v  v  v  v  v  v  v  @  @  @  @  @  &lt;  &lt;  &lt; ###### v  v  v  @  v  v  v 
 ^  ^  ^ ###### v  v  v  v  v  v  v  @ ###### ^  ^  ^  @  ^  ^ ###### &gt;  &gt;  v  @  v  v  v 
 ^  ^  ^ ###### v  v  v  v  v  v  @  v ###### ^  ^  ^  ^  @  ^ ############### @  v  v  v 
 ^  ^  ^ ###### v  v  v  v  v  @  v  v ###### ^  ^  ^  ^  ^  @ ############### @  v  v  v 
 ^  ^  ^ ###### &gt;  &gt;  &gt;  A  @  &lt;  &lt;  &lt; ###### ^  ^  ^  ^  ^  ^  @  @  @  @  @  &lt;  &lt;  &lt;  &lt; 
 v  v  v ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ 
 v  v  v ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ 
 v  v  v ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ 
 v  v  v ###### ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ 
 &gt;  &gt;  &gt;  &gt;  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ 
 ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ 
 ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ ###### ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^  ^ 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</pre>
<p>These hacks are easy to implement and give reasonable paths for grids. However, for even better paths, try the approaches listed in the <a href="#troubleshooting-ugly-path">Ugly paths</a> section.</p></section><section><h2 id="terminology">
<span class="section-number"> 7  </span><span><a href="#terminology"> Vocabulary</a></span><a class="anchor" href="#terminology">#</a>
</h2>
<p>Algorithms textbooks often use mathematical notation with single-letter variable names. On these pages I’ve tried to use more descriptive variable names. Correspondences:</p>
<ul class="org-ul">
<li>
<code>cost</code> is sometimes written as <em>w</em> or <em>d</em> or <em>l</em> or length</li>
<li>
<code>cost_so_far</code> is usually written as <em>g</em> or <em>d</em> or distance</li>
<li>
<code>heuristic</code> is usually written as <em>h</em>
</li>
<li>In A*, the <code>priority</code> is usually written as <em>f</em>, where <em>f</em> = <em>g</em> + <em>h</em>
</li>
<li>
<code>came_from</code> is sometimes written as <em>π</em> or parent or previous or prev</li>
<li>
<code>frontier</code> is usually called OPEN or fringe</li>
<li>locations such as <code>current</code> and <code>next</code> are called <em>states</em> or <em>nodes</em> and written with letters <em>u</em>, <em>v</em>
</li>
</ul>
<p>The OPEN, CLOSED, and reached sets are sets of states. In my code they do not have their own data structures, but instead are contained as part of other data structures:</p>
<ul class="org-ul">
<li>The <em>elements</em> of the <code>frontier</code> are the OPEN set and the <em>priorities</em> of the <code>frontier</code> are the associated priority values.</li>
<li>The <em>keys</em> of the <code>came_from</code> map are the reached set and the <em>values</em> of the <code>came_from</code> map are the parent pointers. Alternatively, if you want to keep the costs, the <em>keys</em> of the <code>cost_so_far</code> map are the reached set and the <em>values</em> of the <code>cost_so_far</code> map are the costs.</li>
<li>the reached set is the union of OPEN and CLOSED.</li>
</ul>
<p>We can reason about the OPEN, CLOSED, and reached sets even though they’re not stored in a separate data structure.</p></section><section><h2 id="more">
<span class="section-number"> 8  </span><span><a href="#more"> More reading</a></span><a class="anchor" href="#more">#</a>
</h2>
<p>License: all the sample code on this page is free to use in your projects. If you need a license for it, you can treat it as Apache v2 licensed by Red Blob Games.</p>
<ul class="org-ul">
<li>Aleksander Nowak has written a <strong>Go version</strong> of this code at <a href="https://github.com/vyrwu/a-star-redblob">https://github.com/vyrwu/a-star-redblob</a><sup class="print-endnote">[19]</sup>
</li>
<li>sark has written a <strong>Rust version</strong> of this code at <a href="https://github.com/sarkahn/sark_pathfinding_rs">https://github.com/sarkahn/sark_pathfinding_rs</a><sup class="print-endnote">[20]</sup>
</li>
<li>Wikipedia links: <ul class="org-ul">
<li>
<a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">Queue</a><sup class="print-endnote">[21]</sup>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Graph_(data_structure)">Graph</a><sup class="print-endnote">[22]</sup>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Breadth-first_search">Breadth-First Search</a><sup class="print-endnote">[23]</sup>
</li>
<li>(Greedy) <a href="https://en.wikipedia.org/wiki/Best-first_search">Best-First Search</a><sup class="print-endnote">[24]</sup>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Dijkstra's_algorithm">Dijkstra’s Algorithm</a><sup class="print-endnote">[25]</sup>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A* Algorithm</a><sup class="print-endnote">[26]</sup>
</li>
</ul>
</li>
</ul></section></main><div class="below-divider">
<p>Email me <a class="email" rel="me" href="mailto:redblobgames@gmail.com">redblobgames@gmail.com</a>, or comment here:</p>
<div class="print-endnote">
<h3>Links</h3>
<ol>
<li>[1]: https://peps.python.org/pep-0526/</li>
<li>[2]: http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html</li>
<li>[3]: https://en.wikipedia.org/wiki/Connected-component_labeling</li>
<li>[4]: http://theory.stanford.edu/~amitp/GameProgramming/MovementCosts.html</li>
<li>[5]: https://en.wikipedia.org/wiki/Connected-component_labeling</li>
<li>[6]: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#Practical_optimizations_and_infinite_graphs</li>
<li>[7]: https://www.aaai.org/ocs/index.php/SOCS/SOCS11/paper/viewFile/4017/4357</li>
<li>[8]: https://www3.cs.stonybrook.edu/~rezaul/papers/TR-07-54.pdf</li>
<li>[9]: https://docs.python.org/3/library/collections.html</li>
<li>[10]: https://en.cppreference.com/w/cpp/container/deque</li>
<li>[11]: https://docs.python.org/2/library/heapq.html</li>
<li>[12]: https://en.cppreference.com/w/cpp/container/priority_queue</li>
<li>[13]: https://www3.cs.stonybrook.edu/~rezaul/papers/TR-07-54.pdf</li>
<li>[14]: https://en.wikipedia.org/wiki/Pairing_heap</li>
<li>[15]: http://theory.stanford.edu/~amitp/GameProgramming/ImplementationNotes.html#set-representation</li>
<li>[16]: https://scholar.google.com/scholar?cluster=8491292501067866547&amp;hl=en&amp;as_sdt=0,5</li>
<li>[17]: https://towardsdatascience.com/a-short-and-direct-walk-with-pascals-triangle-26a86d76f75f</li>
<li>[18]: https://www.keanw.com/2022/06/a-paper-on-our-space-analysis-algorithm-in-the-journal-of-artificial-intelligence-research.html</li>
<li>[19]: https://github.com/vyrwu/a-star-redblob</li>
<li>[20]: https://github.com/sarkahn/sark_pathfinding_rs</li>
<li>[21]: https://en.wikipedia.org/wiki/Queue_(abstract_data_type)</li>
<li>[22]: https://en.wikipedia.org/wiki/Graph_(data_structure)</li>
<li>[23]: https://en.wikipedia.org/wiki/Breadth-first_search</li>
<li>[24]: https://en.wikipedia.org/wiki/Best-first_search</li>
<li>[25]: https://en.wikipedia.org/wiki/Dijkstra’s_algorithm</li>
<li>[26]: https://en.wikipedia.org/wiki/A*_search_algorithm</li>
</ol>
</div>
<div class="comments" role="complementary">
<div id="disqus_thread"><button style="padding:1em;width:100%" onclick="$disqus()">Load comments</button></div>
<script>
function disqus_config(){this.page.url="http://www.redblobgames.com/pathfinding/a-star/implementation.html"}
function $disqus(){$disqus=()=>{};$l("https://redblobgames.disqus.com/embed.js")}
if(document.location.hash.match(/#comment/))setTimeout($disqus,0)
else {new IntersectionObserver(e=>{if(e[0].isIntersecting)$disqus()}).observe(document.getElementById('disqus_thread'))}</script><noscript><a href="https://redblobgames.disqus.com/?url=https://www.redblobgames.com/pathfinding/a-star/implementation.html">View the discussion thread.</a></noscript>
</div>
</div>
<footer><div>
<address>
		  Copyright © <time>2025</time>
                       <a rel="author home copyright" href="https://www.redblobgames.com/">Red Blob Games</a><br><a href="https://www.redblobgames.com/blog/posts.xml"><svg viewBox="0 0 30 30" height="0.8em"><rect width="30" height="30" rx="5" fill="orange"></rect><circle cx="7" cy="23" r="4" fill="white"></circle><path d="M 5,5 A 20,20,0,0,1,25,25 M 5,13 A 12,12,0,0,1,17,25" fill="none" stroke="white" stroke-width="4" stroke-linecap="square"></path></svg>RSS Feed</a>
</address>
<div>
	       <p>Created with <a href="https://orgmode.org/">Emacs Org-mode</a>, from <a href="./implementation.org">implementation.org</a>. Last modified: 9 Feb 2025</p>
</div>
</div></footer>
</body>
</html>
