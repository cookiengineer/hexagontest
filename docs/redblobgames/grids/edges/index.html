<!DOCTYPE html><html lang="en">
<head>

<meta charset="utf-8">
<title>Grid edges</title>
<link rel="canonical" href="https://www.redblobgames.com/grids/edges/">
<!--DO NOT EDIT: generated from redblobgames/grids/edges/index.bxml-->
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="preload" as="image" href="/img/transparent-blob.png">
<link rel="alternate" type="application/atom+xml" title="Blog posts" href="https://www.redblobgames.com/blog/posts.xml">
<meta name="theme-color" content="hsl(0,50%,45%)">
<style>:root{--hue: 0;--bgurl: url("/img/transparent-blob.png")}/*! CSS Copyright 2007-2023 by amitp@cs.stanford.edu (Amit J. Patel)  *//*! I don't mind if you copy my stylesheet.  However, I'd appreciate it if you gave me credit. */body{--serif: "Iowan Old Style",Cambria,Georgia,serif;--sans-serif: "Avenir Next",Candara,Ubuntu,"Fira Sans",system-ui,"Segoe UI",sans-serif;--monospace: "Roboto Mono","Cascadia Code",Consolas,monospace,"Segoe UI Symbol",Symbol;--body-width: calc(100vw - 2.25rem);--font-size: calc(0.625rem + 1vw);--line-height: calc(1.5 * var(--font-size));font-family:var(--sans-serif);font-size:var(--font-size);line-height:1.5em;min-height:95%}@media (min-width: 34.375em){body{--body-width: min(20.6rem + 33vw, 41.25rem);--font-size: calc(var(--body-width) / 33)}}main{font-family:var(--serif)}h1,h2,h3,h4,h5,h6,figcaption,.sans-serif{font-family:var(--sans-serif);text-wrap:balance}tt,code,kbd,samp,pre{font-family:var(--monospace);font-size:0.8em}pre :is(tt, code, kbd, samp){font-size:unset}#table-of-contents{background-color:#fff;padding-left:1em;width:18em;float:right}#table-of-contents:after{clear:right}nav,#table-of-contents{font-family:var(--sans-serif);font-size:calc(var(--font-size) / 1.25)}nav a,#table-of-contents a{text-decoration-color:hsl(var(--hue), 20%, 90%)}@media screen{header,section>h2{text-shadow:0px 2px 5px rgba(0,0,0,0.8);text-rendering:optimizeLegibility}}h1{font-size:2.0em;margin:0;line-height:calc(1.5 * var(--line-height))}h1 .subheading{font-size:0.5em;line-height:var(--line-height)}sup,sub{position:relative;vertical-align:baseline;font-size:0.75em;line-height:0;padding-left:0.125em}sup{top:-0.5em}sub{bottom:-0.25em}details summary{cursor:pointer}*{box-sizing:border-box}html,body{margin:0;padding:0}html{background-color:#e4e4e0;color:#000}body{background-color:#fff;color:#333}header{display:block;text-align:center}header>h1{padding-top:var(--line-height)}@media screen{header,footer,.divider,section>h2{color:#fff;background-color:hsl(var(--hue), 50%, 45%);background-image:var(--bgurl), var(--bgurl), linear-gradient(180deg, hsl(var(--hue), 50%, 45%) 0%, hsl(var(--hue), 75%, 30%) 100%);background-position:0 0, 16px 16px;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}header a,footer a,.divider a,section>h2 a{color:hsl(var(--hue), 40%, 90%);background:unset;text-decoration:none}header a:hover,footer a:hover,.divider a:hover,section>h2 a:hover{background-color:rgba(0,0,0,0.5);text-decoration:underline}}footer a,.divider a{text-decoration:underline}main{margin-inline:0;padding-inline:0}section{margin:var(--line-height) 0}section>*{width:var(--body-width);max-width:100%}.comments{width:calc(1.5 * var(--body-width));max-width:100%}@media screen{.comments,.below-divider{background-color:#e6e6e5}}.comments{padding-bottom:1.25em;font-size:1.0em}.comments .comment-author{text-shadow:1px 1px 3px #fff}section>h2{--h2-margin: 3em;margin:var(--line-height) auto;padding:calc(var(--line-height) / 2 - 1px) 0;font-size:1.25em;width:calc(2 * var(--h2-margin) + var(--body-width));max-width:100%}section>h2>span{display:inline-block;margin-left:var(--h2-margin)}section>h2 a.anchor{float:right;width:calc(var(--h2-margin));text-align:center;color:hsl(var(--hue), 50%, 45%)}section>h2:hover a.anchor{color:hsl(var(--hue), 20%, 80%)}h3{--h2-margin: 3em;margin:var(--line-height) auto;font-size:1.125em}h3 a.anchor{float:right;width:calc(var(--h2-margin));text-align:center;color:hsl(var(--hue), 20%, 80%)}@media (min-width: 34.375em){h3 a.anchor{margin-right:calc(0em - var(--h2-margin))}}h4 a.anchor,h5 a.anchor,h6 a.anchor{padding-left:1em;color:hsl(var(--hue), 20%, 80%)}h3:hover a.anchor,h4:hover a.anchor,h5:hover a.anchor,h6:hover a.anchor{color:hsl(var(--hue), 50%, 40%)}header nav{display:block}header nav ul{display:flex;flex-flow:row wrap;justify-content:center;line-height:1.0;margin:0}header nav ul li{display:inline-block;padding:0.1em 0.3em;text-align:center;flex:0 0 4em;align-self:center;white-space:nowrap}header nav ul li a{display:block;font-weight:bold;text-decoration:none}header,.divider,section>h2{border-bottom:1px solid #000}.divider,section>h2{border-top:1px solid #000}.divider{min-height:calc(2 * var(--line-height));text-align:center}.below-divider{padding-top:var(--line-height);border-bottom:1px solid black}.below-divider>p:first-child{font-size:1.25em;text-align:center;margin-top:0}footer{--footer-padding-y: calc(var(--line-height) / 2);--footer-padding-x: var(--font-size);padding:var(--footer-padding-y) var(--footer-padding-x);border-top:1px solid #000}footer>div>address{display:block}footer>div>*{text-align:center}@media (min-width: 50em){footer>div{margin:0 auto;display:flex;flex-flow:row wrap;justify-content:center;max-width:calc(2 * var(--body-width));width:calc(100vw - 2 * var(--footer-padding-x))}footer>div>address{flex:0 1 20em;align-self:center;text-align:left}footer>div>div{flex:1 1 20em;align-self:center;text-align:right}footer>div>div>p,footer>div>div>div{margin-top:0}}h2:target{animation:target-attention 0.4s 1;font-size:2.0em}@keyframes target-attention{0%{transform:scale(1.1)}100%{transform:scale(1.1)}}div:target{border:1px dashed #888}kbd kbd{padding:0.1em 0.4em;margin:0 0.1em 0.2em 0.1em;font-size:0.75em;white-space:nowrap;background-color:#ddd;color:#242;border:1px solid rgba(0,0,0,0.2);border-radius:0.2em;box-shadow:inset 0 0 1px 1px #fff,0 2px 0 rgba(0,0,0,0.3)}samp,kbd{background-color:#f3f3f2}code,samp{color:#442}kbd{margin:0 0.4em;color:#252}section li::marker{font-family:var(--sans-serif);color:hsl(var(--hue), 50%, 40%)}img{max-width:100%;height:auto;-ms-interpolation-mode:bicubic}section figcaption{font-size:0.75em;line-height:1.1;text-align:center}a{color:hsl(var(--hue), 50%, 45%);text-decoration-color:hsl(var(--hue), 20%, 80%);text-underline-offset:0.25em}a:hover{text-decoration:underline;text-decoration-color:hsl(var(--hue), 50%, 45%);background:hsla(var(--hue), 50%, 50%, 0.1)}:focus-visible{outline-color:hsl(var(--hue), 50%, 45%)}.draft{font-family:var(--serif);font-size:calc(4 * var(--font-size));letter-spacing:-0.1em;color:#eee;opacity:0.5;text-align:center;transform:rotate(-5deg);line-height:1.0;position:absolute;top:0;height:0;left:25%;width:50%;pointer-events:none}@media (min-width: 34.375em){section p,section li{hanging-punctuation:first last;text-wrap:pretty;hyphens:auto;hyphenate-limit-chars:7}}nav,.section-number,address,time{font-variant-numeric:oldstyle-nums}.w-auto,section>.w-auto{width:auto}.w-full,section>.w-full{width:100%}.w-150b,section>.w-150b{width:calc(1.5 * var(--body-width))}.select-none{user-select:none;-webkit-user-select:none}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}.text-sm{font-size:0.875em}.font-sans{font-family:var(--sans-serif)}.font-serif{font-family:var(--serif)}.font-mono{font-family:var(--monospace)}.normal-nums{font-variant-numeric:normal}.oldstyle-nums{font-variant-numeric:oldstyle-nums}p,figure,ul,ol{margin:var(--line-height) 0}header>*,section>*,footer>*,main>address,.comments{margin-inline:auto}figure{text-align:center}figure pre{text-align:left}li>ul,li>ol{margin-top:0;margin-bottom:0}figure img,figure svg,figure canvas{max-width:100%}dt{font-weight:bold}pre{width:var(--body-width);max-width:100%;line-height:1.4;overflow:auto;border-block:1px solid #ccc;border-inline-width:0}pre.simple,.comments pre{overflow:auto;width:calc(var(--body-width) * 1.2);border:none;background:transparent;background-color:transparent;box-shadow:none}pre.snippet,pre.src{border-top-style:dashed;border-bottom-style:dashed}section>pre:only-child{padding-bottom:var(--font-size);border-bottom:1px solid rgba(0,0,0,0.5)}blockquote{font-style:italic;text-wrap:balance}table.standard2024{font-family:var(--sans-serif);font-size:0.875em;border:2px solid white;border-collapse:collapse;overflow-x:auto}table.standard2024 th{background-color:#e8e8e3;border:2px solid white;padding:0 0.5em}table.standard2024 td{background-color:#fff;border:1px solid #f3f3f2;border-right-color:#babaab;padding:0 0.5em}table.standard2024 thead{border-bottom:2px solid #babaab}table.standard2024 thead th{background:linear-gradient(to top, #e8e8e3, #f4f4f1, #fafaf9)}table.standard{font-family:var(--sans-serif);font-size:0.875em;border-block:2px solid hsl(var(--hue), 10%, 50%);border-collapse:collapse;overflow-x:auto;text-align:left}table.standard td,table.standard th{border-bottom:1px solid #f3f3f2;padding:0 0.5em}table.standard :is(td, th):not(:last-child){border-right:1px solid #babaab}table.standard td{background-color:hsl(var(--hue), 10%, 97%);border-bottom-color:white}table.standard thead{border-bottom:2px solid hsl(var(--hue), 10%, 50%);vertical-align:bottom}table.standard tfoot{border-top:2px solid hsl(var(--hue), 10%, 50%);vertical-align:bottom}table.standard thead th{background:linear-gradient(to top, hsl(var(--hue), 10%, 85%), hsl(var(--hue), 15%, 87%), hsl(var(--hue), 15%, 90%));border-bottom:unset}table.standard tbody th{background-color:hsl(var(--hue), 10%, 95%);border-bottom:1px solid white}table.standard tr:hover :is(td, th){background-color:hsl(var(--hue), 25%, 93%)}aside,p.note,div.note>p{width:calc(--body-width - 2em);padding:1em;background:#eee;border:1px solid #ddd;box-shadow:0 8px 6px -6px rgba(0,0,0,0.4)}tt,code{padding:0 2px}pre :is(tt, code){padding:unset}main>address,section>address,section>time{display:block;width:var(--body-width);max-width:100%;font-family:var(--sans-serif);text-align:right}form{margin:0}input{accent-color:hsl(var(--hue), 50%, 50%)}input[type="text"]{max-width:100%;border:1px solid rgba(0,0,0,0.7);background-color:#f8f8f4;color:#000;text-align:center;font-weight:bold}input[type="text"]:focus{background-color:#fffff4}input::placeholder{color:#aaa}input[type="search"][name="q"]{box-shadow:inset 0 0.1em 0.3em 0 rgba(0,0,0,0.5);border-radius:0.6em;padding:0.3em 0.6em;border-width:0}button{touch-action:manipulation;cursor:pointer;user-select:none}.TODO{color:#bf4040;background:#e8e3e3;border:1px solid #bf4040;margin-left:0.5ex}.DONE{color:#4040bf;background:#e3e3e8;border:1px solid #4040bf}.src .constant{font-style:oblique}.src .comment-delimiter,.src .nxml-comment-delimiter{color:#4488ff}.src .comment,.src .nxml-comment-content{color:#006699}.src .builtin{color:#508b20}.src .warning{color:#cc0000}.src .function-name{color:#268bd2;font-weight:bold}.src .variable-name{font-weight:bold;color:#5c3d5c}.src .type{color:#6c71c4}.src .constant-face{color:#d33682}.src .doc{color:#666666;background-color:#e2e6e8}.src .string{color:#888888}.src .preprocessor{color:#859900}.src .negation-char,.src .sh-escaped-newline{color:#ff0000}.src .todo{color:#ffffff;background:#dc322f}.src .note{color:#ffffff;background:#2aa198}.src .hack{color:#ffffff;background:#859900}.src .operator{color:black;font-weight:bold}.src .paren{color:#a0a090;font-weight:bold}.src .keyword{color:#679;font-weight:bold}.src .minor-control-construct{color:#406abf;font-weight:bold}.src .major-control-construct{color:#bf4040}.src-cpp .constant{color:#999999}.src-emacs-lisp .paren{color:#c9c9c4}.src-sh .string,.src-sh .comment{color:inherit}.src-python .highlight-indentation{border-right:2px solid #eeeeee}.src-css .css-selector{color:#478547}.src-css .css-property{color:#406abf}.src-xml .nxml-element-prefix{color:#bf40bf}.src-xml .nxml-element-local-name{color:#406abf;font-weight:normal}.src-xml .nxml-attribute-local-name{color:#478547}.src-xml .nxml-element-colon{color:#a3adc2}.src-xml .nxml-tag-delimiter,.src-xml .nxml-tag-slash{color:#9cabc9;font-weight:bold}table.standard td.left,table.standard th.left{text-align:left}table.standard td.center,table.standard th.center{text-align:center}table.standard td.right,table.standard th.right{text-align:right}@media screen{*[class^="section-number"]{color:hsl(var(--hue), 20%, 50%)}h2 .section-number{display:inline-block;margin-left:0;padding-left:0.5em;text-align:center;width:var(--h2-margin);color:hsl(var(--hue), 50%, 80%)}h2 .section-number+span{margin-left:0}h3>.section-number{float:left;text-align:center;width:2.7em;margin-right:0.3em;color:hsl(var(--hue), 25%, 90%);background:hsl(var(--hue), 50%, 50%);background-image:var(--bgurl), var(--bgurl);background-position:0 0, 16px 16px;border-radius:0.25em;text-shadow:0px 2px 5px rgba(0,0,0,0.8)}}@media screen and (min-width: 34.375em){h3>.section-number{height:2em;margin-left:-3em;margin-top:-0.3em;padding-top:0.3em;border-block:1px solid black}h3>a.anchor{background:url(https://www.redblobgames.com/img/svg-blob-mini.svg) no-repeat center center;background-size:2cap 2cap}h3:hover>a.anchor{background:none}}.print-endnote{display:none}@media print{@page{margin:0.5in}body{--font-size: 14pt;--serif: "Book Antiqua", "Times New Roman", serif;--sans-serif: "Helvetica", sans-serif;--monospace: "Courier", "Courier New", monospace}h2,h3{page-break-after:avoid}figure{page-break-inside:avoid}p,li{orphans:5;widows:5}section p a,section li a{text-decoration:underline;text-decoration-color:#ddd}header nav,.comments{display:none}.print-endnote{display:unset}.print-endnote li{list-style-type:none;word-break:break-all}.print-endnote img{width:2.5em;vertical-align:bottom}}

@media print{header::before{position:absolute;right:0;top:0;content:url(https://chart.apis.google.com/chart?chs=120x120&cht=qr&chl=https%3A%2F%2Fwww.redblobgames.com%2Fgrids%2Fedges%2F);}}
	  
      svg { pointer-events: none; }
      text { text-anchor: middle; font-family: var(--sans-serif); }
      .font-small text { font-size: 50%; }
      line, polygon { stroke-linecap: round; }
      line.border { fill: none; stroke: hsl(45, 20%, 20%); stroke-width: 3px; }
      line.border.joined { stroke-opacity: 0.1; }
      line.border.wall { stroke: hsl(45, 0%, 0%); stroke-width: 8px; }
      line.pipe-outer { fill: none; stroke: hsl(30, 50%, 40%); stroke-width: 15px; }
      line.pipe-inner { fill: none; stroke: hsl(30, 100%, 95%); stroke-width: 12px; }
      line.light { stroke: hsl(30, 100%, 80%); stroke-width: 2px; }
      circle.pipe { fill: hsl(180, 50%, 85%); stroke: hsl(180, 50%, 30%); stroke-width: 1.5px; }
      polygon { fill-opacity: 0.5; pointer-events: visible; cursor: pointer; }
      .tile { fill: hsl(200, 30%, 50%); transition: 0.1s fill; }
      .tile[data-parity="1"] { fill: hsl(200, 50%, 70%); }
      .edge { fill: hsl(30, 30%, 50%); transition: 0.1s fill; }
      .edge[data-parity="1"] { fill: hsl(30, 50%, 70%); }
      .corner { fill: hsl(0, 50%, 50%); transition: 0.1s fill; }
      .tile:hover, .tile.highlighted { fill-opacity: 0.7; fill: hsl(180, 100%, 85%); stroke: hsl(180, 100%, 50%); stroke-width: 4px; }
      .edge:hover, .edge.highlighted { fill-opacity: 0.7; fill: hsl(60, 100%, 85%); stroke: hsl(60, 100%, 50%); stroke-width: 4px; }
      .corner:hover, .corner.highlighted { fill-opacity: 0.7, fill: hsl(0, 100%, 85%); stroke: hsl(0, 50%, 50%); stroke-width: 4px; }
      .tile.wall { fill-opacity: 1.0; fill: hsl(200, 20%, 40%); }
      .tile.light { fill: hsl(60, 30%, 90%); }
      
      .onhover { fill-opacity: 0.1; }
      .onhover:hover { fill-opacity: 1.0; }

      li.highlight { background: hsl(60, 10%, 95%); }
      div.two-column { display: grid; grid-template-columns: repeat(2, 1fr); grid-column-gap: 1em; }
      div.two-column > figure { margin: 0; }
  </style>
<script>function $l(s,e,d){d=document;if(d.location.hostname!='localhost'){e=d.createElement('script');e.async=true;e.src=s;e.dataset.timestamp=+new Date();d.body.appendChild(e)}}</script>
</head>
<body class="gameprog">
<header><h1>Grid edges</h1>
<div class="subheading">
                 from <a href="https://www.redblobgames.com/">Red Blob Games</a>
</div>
<nav><search><form action="https://www.google.com/search">
<ul> <li><a href="https://www.redblobgames.com/">Home</a></li> <li><a href="https://www.redblobgames.com/blog/">Blog</a></li> <li><a href="https://pinboard.in/u:amitp/t:gamedev/">Links</a></li> <li><a href="https://bsky.app/profile/redblobgames.com">Bluesky</a></li> <li><a rel="me" href="http://www-cs-students.stanford.edu/~amitp/">About</a></li> <li> </li> <li><input type="search" name="q" placeholder="Search" size="8"></li>
</ul>
<input type="hidden" name="hq" value="site:www.redblobgames.com OR site:theory.stanford.edu/~amitp/ OR site:www-cs-students.stanford.edu/~amitp/ OR site:amitp.blogspot.com OR site:simblob.blogspot.com">
</form></search></nav></header><main><address>15 Jan 2019, updated Jun 2020</address>
<section><p>Games with grids usually use the <em>tiles</em> but there are also cool things to do with <em>edges</em> and <em>vertices</em>. For construction games the edges can be useful for blocking connections between tiles (walls, chasms, windows) and allowing connections between tiles (doors, pipes, wires).</p>
<p>Let's start with an example: building walls. A common approach to implementing walls is to place thick walls on the tiles. An alternative is to place thin walls on the edges. <strong>Click</strong> or tap on the tiles or edges to toggle the walls:</p>
<div class="two-column">
<figure id="diagram-tile-wall"><svg class="select-none" v-cloak="1" viewBox="-2 -2 904 504"><g v-for="tile in tiles" v-bind:key="tile.id" v-on:click="toggleTile(tile)"><polygon class="tile" v-bind:class="{wall: tileState[tile]}" v-bind:points="tile.makePolygon(0)" data-parity="0"></polygon></g><g v-for="edge in edges" v-bind:key="edge.id + '-overlay'"><line class="border joined" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line></g></svg><figcaption>Thick walls on tiles</figcaption></figure><figure id="diagram-edge-wall"><svg class="select-none" v-cloak="1" viewBox="-2 -2 904 504"><g v-for="tile in tiles" v-bind:key="tile.id"><polygon class="tile" v-bind:points="tile.makePolygon(0)" data-parity="0"></polygon></g><g v-for="edge in edges" v-bind:key="edge.id + '-overlay'" v-on:click="toggleEdge(edge)"><polygon class="edge" v-bind:points="edge.makePolygon(1)" data-parity="0" style="fill-opacity: 0.01"></polygon><line class="border" v-bind:class="{joined: !edgeState[edge], wall: edgeState[edge]}" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line></g></svg><figcaption>Thin walls on edges</figcaption></figure>
</div></section><section><h2 id="examples">
<span><a href="#examples">Examples</a></span><a class="anchor" href="#examples">#</a>
</h2>
<p>Sometimes we want <em>both</em> tiles and edges. I try to make one of the two <em>primary</em> and then calculate the other one. In this example showing grid lighting, the tiles are primary. We can light edges when <em>either</em> tile is lit. <strong>Click</strong> or tap on tiles:</p>
<figure id="diagram-tile-light"><svg class="select-none" v-cloak="1" viewBox="-2 -2 904 504"><g v-for="tile in tiles" v-bind:key="tile.id" v-on:click="toggleTile(tile)"><polygon class="tile" v-bind:class="{light: tileState[tile]}" v-bind:points="tile.makePolygon(0)" data-parity="0"></polygon></g><line v-for="edge in edges" class="border" v-bind:class="{light: edgeState[edge]}" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line></svg><figcaption>Tiles are primary; edges are secondary (OR)</figcaption></figure><p>Consider the example of pipes/wires between adjacent tiles. We want to know which tiles are connected to the pipe network, but we also want to know which edges connect tiles to each other. If we make the tiles primary, we can place edges when <em>both</em> tiles are marked. <strong>Click</strong> or tap on tiles:</p>
<figure id="diagram-tile-pipe"><svg class="select-none" v-cloak="1" viewBox="-2 -2 904 504"><g v-for="tile in tiles" v-bind:key="tile.id" v-on:click="toggleTile(tile)"><polygon class="tile" v-bind:points="tile.makePolygon(0)" data-parity="0"></polygon></g><g v-for="edge in edges" v-bind:key="edge.id + '-overlay'"><line class="border" v-bind:class="{joined: edgeState[edge]}" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line><line class="pipe-outer" v-if="edgeState[edge]" v-bind:x1="edge.joins[0].x" v-bind:y1="edge.joins[0].y" v-bind:x2="edge.joins[1].x" v-bind:y2="edge.joins[1].y"></line><line class="pipe-inner" v-if="edgeState[edge]" v-bind:x1="edge.joins[0].x" v-bind:y1="edge.joins[0].y" v-bind:x2="edge.joins[1].x" v-bind:y2="edge.joins[1].y"></line></g><circle v-for="tile in tiles" v-bind:key="tile.id + '-pipe'" v-if="tileState[tile]" class="pipe" v-bind:cx="tile.x" v-bind:cy="tile.y" r="20"></circle></svg><figcaption>Tiles are primary; edges are secondary (AND)</figcaption></figure><p>Alternatively, we can make the edges primary, and place pipes on tiles when <em>any</em> edge is marked. <strong>Click</strong> or tap on edges:</p>
<figure id="diagram-edge-pipe"><svg class="select-none" v-cloak="1" viewBox="-2 -2 904 504"><g v-for="edge in edges" v-bind:key="edge.id + '-overlay'" v-on:click="toggleEdge(edge)"><polygon class="edge" v-bind:points="edge.makePolygon(1)" data-parity="0"></polygon><line class="border" v-bind:class="{joined: edgeState[edge]}" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line><line class="pipe-outer" v-if="edgeState[edge]" v-bind:x1="edge.joins[0].x" v-bind:y1="edge.joins[0].y" v-bind:x2="edge.joins[1].x" v-bind:y2="edge.joins[1].y"></line><line class="pipe-inner" v-if="edgeState[edge]" v-bind:x1="edge.joins[0].x" v-bind:y1="edge.joins[0].y" v-bind:x2="edge.joins[1].x" v-bind:y2="edge.joins[1].y"></line></g><circle v-for="tile in tiles" v-bind:key="tile.id + '-pipe'" v-if="tileState[tile]" class="pipe" v-bind:cx="tile.x" v-bind:cy="tile.y" r="20"></circle></svg><figcaption>Edges are primary; tiles are secondary (OR)</figcaption></figure><p>Here's an example of adding thin walls when <em>exactly one</em> neighboring tile has a thick wall. <strong>Click</strong> or tap on tiles:</p>
<figure id="diagram-tile-thinwalls"><svg class="select-none" v-cloak="1" viewBox="-2 -2 904 504"><g v-for="tile in tiles" v-bind:key="tile.id" v-on:click="toggleTile(tile)"><polygon class="tile" v-bind:class="{wall: tileState[tile]}" v-bind:points="tile.makePolygon(0)" data-parity="0"></polygon></g><line v-for="edge in edges" class="border" v-bind:class="{wall: edgeState[edge]}" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line></svg><figcaption>Tiles are primary; edges are secondary (XOR)</figcaption></figure><p>Whenever possible, I make either tiles or edges primary, and calculate the other using a function. I find this less error prone than putting constraints on what combinations of tiles and edges are allowed. The "pipe" style connectors and the "wall" style dividers use the same logic underneath. A pipe is drawn between the tile <em>centers</em>; a wall is drawn between the <em>corners</em>.</p></section><section><h2 id="coordinates">
<span><a href="#coordinates">Coordinate systems</a></span><a class="anchor" href="#coordinates">#</a>
</h2>
<p>Coordinates for square tiles have two different conventions. In math and in 3D graphics, Y increases upwards; in many 2D graphics systems, Y increases downwards. On this page I'm going to show Y increasing downwards.</p>
<figure id="diagram-tile-coordinates"><svg class="select-none" v-cloak="1" viewBox="-2 -2 904 504"><g v-for="tile in tiles" v-bind:key="tile.id"><polygon class="tile" v-bind:points="tile.makePolygon(0)" v-bind:data-parity="tile.parity"></polygon><text v-bind:x="tile.x" v-bind:y="tile.y">{{tile.q}}, {{tile.r}}</text></g><line v-for="edge in edges" class="border" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line></svg></figure><p>How about edges? We could label the four sides of each square:</p>
<figure id="diagram-side-coordinates" class="font-small"><svg class="select-none" v-cloak="1" viewBox="-2 -2 304 204"><g v-for="tile in tiles" v-bind:key="tile.id"><polygon class="tile" v-bind:points="tile.makePolygon(0)" v-bind:data-parity="tile.parity"></polygon><g v-bind:transform="`translate(${tile.x},${tile.y})`"><text y="-40">{{tile.q}},{{tile.r}},N</text><text y="45">{{tile.q}},{{tile.r}},S</text><text y="-40" transform="rotate(-90)">{{tile.q}},{{tile.r}},W</text><text y="-40" transform="rotate(90)">{{tile.q}},{{tile.r}},E</text></g></g><line v-for="edge in edges" class="border" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line></svg></figure><p>In many situations we want to treat <code>0,0,S</code> and <code>0,1,N</code> as the same edge, and similarly <code>0,0,E</code> and <code>1,0,W</code>. In these situations we can <strong>keep the N and W</strong> sides and discard S and E. We could've kept S instead of N, or E instead of W, but I'll work out the details for N and W.</p>
<figure id="diagram-edge-coordinates" class="font-small"><svg class="select-none" v-cloak="1" viewBox="-2 -2 304 204"><g v-for="edge in edges" v-bind:key="edge.id"><polygon class="edge" v-bind:points="edge.makePolygon(1)" v-bind:data-parity="edge.parity"></polygon><line class="border" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line></g><g v-for="tile in tiles" v-bind:key="tile.id"><g v-bind:transform="`translate(${tile.x},${tile.y})`"><text y="-40">{{tile.q}},{{tile.r}},N</text><text y="-40" transform="rotate(-90)">{{tile.q}},{{tile.r}},W</text></g></g></svg></figure><p>Given a tile <code>q,r</code> its four bordering edges are <code>q,r,N</code> ; <code>q,r,W</code> ; <code>q,r+1,N</code> ; <code>q+1,r,W</code>.</p>
<figure id="diagram-borders" class="font-small"><svg class="select-none" v-cloak="1" viewBox="-2 -2 404 304"><g v-for="tile in tiles" v-bind:key="tile.id"><polygon class="tile" v-bind:class="{highlighted: highlighted.id === tile.id}" v-bind:points="tile.makePolygon(0)" v-bind:data-parity="tile.parity" v-on:touchstart.prevent="" v-on:pointerdown="$event.target.releasePointerCapture($event.pointerId); highlighted = tile" v-on:pointerover="highlighted = tile"></polygon><g v-if="tile.equals(highlighted)" v-bind:transform="`translate(${tile.x},${tile.y})`"><text>{{tile.q}},{{tile.r}}</text><text y="-40">{{tile.q}},{{tile.r}},N</text><text y="45">{{tile.q}},{{tile.r+1}},N</text><text y="-40" transform="rotate(-90)">{{tile.q}},{{tile.r}},W</text><text y="-40" transform="rotate(90)">{{tile.q+1}},{{tile.r}},W</text></g></g><line v-for="edge in edges" class="border" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line></svg></figure><p>The rules for edges depend on whether it's an <code>N</code> or <code>W</code> edge. Given an edge <code>q,r,N</code> its two joining tiles are <code>q,r-1</code> ; <code>q,r</code>. Given an edge <code>q,r,W</code> its two joining tiles are <code>q-1,r</code> ; <code>q,r</code>.</p>
<figure id="diagram-joins" class="font-small"><svg class="select-none" v-cloak="1" viewBox="-2 -2 404 304"><g v-for="edge in edges" v-bind:key="edge.id"><polygon class="edge" v-bind:class="{highlighted: highlighted.id === edge.id}" v-bind:points="edge.makePolygon(1)" v-bind:data-parity="edge.parity" v-on:touchstart.prevent="" v-on:pointerdown="$event.target.releasePointerCapture($event.pointerId); highlighted = edge" v-on:pointerover="highlighted = edge"></polygon><line class="border" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line></g><g v-for="tile in tiles" v-bind:key="tile.id" v-bind:transform="`translate(${tile.x},${tile.y})`"><text v-if="highlighted.joins.some(t=&gt;t.equals(tile))">{{tile.q}},{{tile.r}}</text><!-- must be a cleaner way to do this --><text v-if="highlighted.q === tile.q &amp;&amp; highlighted.r === tile.r &amp;&amp; highlighted.s == 'N'" y="-40">{{tile.q}},{{tile.r}},N</text><text v-if="highlighted.q === tile.q &amp;&amp; highlighted.r === tile.r &amp;&amp; highlighted.s == 'W'" y="-40" transform="rotate(-90)">{{tile.q}},{{tile.r}},W</text></g></svg></figure><p>For more details, including coordinates for corners and more tile+edge+corner relationships, see <a href="/grids/parts/">my guide to grids</a>.</p></section><section><h2 id="geometry">
<span><a href="#geometry">Pixel lookup</a></span><a class="anchor" href="#geometry">#</a>
</h2>
<p>In some games we want to be able to determine which tile/edge is closest to the mouse position. When working with tiles, we find the closest tile by looking at squares. These squares are exactly the same as the tiles. It's so simple we don't even think about it! Mouse over the map to see the area of pixels that would activate a tile (touch not supported).</p>
<figure id="diagram-tile"><svg class="select-none" v-cloak="1" viewBox="-2 -2 604 304"><g v-for="tile in tiles" v-bind:key="tile.id"><polygon class="tile" v-bind:points="tile.makePolygon(blend)" v-bind:data-parity="tile.parity"></polygon></g><g v-for="edge in edges" v-bind:key="edge.id + '-overlay'"><line class="border" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line></g></svg></figure><p>When working with tile edges, we find the closest tile by looking squares at a 45° angle. Each square is made from <em>two</em> tile centers and <em>two</em> tile corners. Mouse over the map to see the area of pixels that would activate an edge (touch not supported).</p>
<figure id="diagram-edge"><svg class="select-none" v-cloak="1" viewBox="-2 -2 604 304"><g v-for="edge in edges" v-bind:key="edge.id"><polygon class="edge" v-bind:points="edge.makePolygon(blend)" v-bind:data-parity="edge.parity"></polygon></g><g v-for="edge in edges" v-bind:key="edge.id + '-overlay'"><line class="border" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line></g></svg></figure><p>If we want the mouse to work with both tiles and edges, we can build polygons that work with both. The tiles are detected with small squares, and edges are detected with hexagons. Move the slider to control the sizes, and mouse over the map to see what is activated (touch not supported).</p>
<figure id="diagram-hybrid"><svg class="select-none" v-cloak="1" viewBox="-2 -2 604 304"><g v-for="tile in tiles" v-bind:key="tile.id"><polygon class="tile" v-bind:points="tile.makePolygon(blend)" v-bind:data-parity="tile.parity"></polygon></g><g v-for="edge in edges" v-bind:key="edge.id"><polygon class="edge" v-bind:points="edge.makePolygon(blend)" v-bind:data-parity="edge.parity"></polygon></g><g v-for="edge in edges" v-bind:key="edge.id + '-overlay'"><line class="border" v-bind:x1="edge.endpoints[0].x" v-bind:y1="edge.endpoints[0].y" v-bind:x2="edge.endpoints[1].x" v-bind:y2="edge.endpoints[1].y"></line></g></svg><div style="display: grid; grid-template-columns: max-content 1fr max-content; grid-column-gap: 0.5em">
<div>Favor tiles ←</div>
<div><input v-model="blend" type="range" style="width:100%" min="0" max="1" step="0.01"></div>
<div>→ favor edges</div>
</div></figure><p>Alternatively, calculate both the mouseover tile and mouseover edge, and pick the one that's closer to the mouse pointer.</p></section><section><h2 id="corners">
<span><a href="#corners">Corner pieces</a></span><a class="anchor" href="#corners">#</a>
</h2>
<p>If you're working with square tiles, edges, and corners all in the same system, there's a clever trick of using the low bit of x and the low bit of y: 00 = corner, 01 = west edge, 10 = north edge, 11 = tile. <svg width="1em" height="1em" viewBox="0 0 100 100"><rect width="100" height="100" class="edge" data-parity="1"></rect><rect width="25" height="25" class="corner"></rect><rect x="25" y="25" width="75" height="75" class="tile"></rect></svg> Let's see how this works. <strong>Move the slider</strong> to see how this data is stored in an array.</p>
<figure id="diagram-corner-coordinates"><svg class="select-none" v-cloak="1" viewBox="-40 -45 665 370" v-on:pointerout="highlighted = {s:'?'}"><text v-for="row in 2*rows+1" text-anchor="middle" v-bind:fill-opacity="2*blend" v-bind:x="-35" v-bind:y="SPACING/2 * (row - 0.85)">{{row-1}}</text><text v-for="col in 2*cols+1" text-anchor="middle" v-bind:fill-opacity="2*blend" v-bind:y="-30" v-bind:x="SPACING/2 * (col - 1.0)">{{col-1}}</text><g v-for="corner in corners" v-bind:key="corner.id" v-on:touchstart.prevent="" v-on:pointerdown="$event.target.releasePointerCapture($event.pointerId); highlighted = corner" v-on:pointerover="highlighted = corner"><polygon class="corner" v-bind:class="{highlighted: highlighted.id === corner.id}" v-bind:points="corner.makePolygon(blend)" v-bind:data-parity="0"></polygon><text v-bind:x="corner.x" v-bind:y="corner.y" text-anchor="middle" font-size="50%" dy="0.2em" v-bind:fill-opacity="blend-0.1">{{corner.q}},{{corner.r}},NW</text></g><g v-for="tile in tiles" v-bind:key="tile.id" v-on:touchstart.prevent="" v-on:pointerdown="$event.target.releasePointerCapture($event.pointerId); highlighted = tile" v-on:pointerover="highlighted = tile"><polygon class="tile" v-bind:class="{highlighted: highlighted.id === tile.id}" v-bind:points="tile.makePolygon(blend)" v-bind:data-parity="0"></polygon><text v-bind:x="tile.x" v-bind:y="tile.y" text-anchor="middle" dy="0.2em" v-bind:fill-opacity="blend-0.1">{{tile.q}},{{tile.r}}</text></g><g v-for="edge in edges" v-bind:key="edge.id" v-on:touchstart.prevent="" v-on:pointerdown="$event.target.releasePointerCapture($event.pointerId); highlighted = edge" v-on:pointerover="highlighted = edge"><polygon class="edge" v-bind:class="{highlighted: highlighted.id === edge.id}" v-bind:points="edge.makeRectangle(blend)" v-bind:data-parity="1"></polygon><text text-anchor="middle" font-size="50%" dy="0.2em" v-bind:fill-opacity="blend" v-bind:transform="'translate(' + edge.x + ',' + edge.y + ') ' + (edge.s === 'W' ? 'rotate(-90)' : '')">{{edge.q}},{{edge.r}},{{edge.s}}</text></g></svg><div style="display: grid; grid-template-columns: max-content 1fr max-content; grid-column-gap: 0.5em">
<div>Render like this ←</div>
<div><input v-model="blend" type="range" style="width:100%" min="0.1" max="0.5" step="0.01"></div>
<div>→ store in array</div>
</div>
<ul style="text-align:left">
<li v-bind:class="highlighted.s === 'v'? 'highlight': ''">Store <svg width="1em" height="1em" viewBox="0 0 100 100" style="background:#eee"><rect v-bind:width="100*blend" v-bind:height="100*blend" class="corner"></rect></svg>  <strong>corners</strong>  <code>q,r,NW</code> in <code>array[2*q][2*r]</code>
</li>
<li v-bind:class="highlighted.s === 'N'? 'highlight': ''">Store <svg width="1em" height="1em" viewBox="0 0 100 100" style="background:#eee"><rect v-bind:x="100*blend" v-bind:width="100*(1-blend)" v-bind:height="100*blend" class="edge"></rect></svg>  <strong>N edges</strong>  <code>q,r,N</code> in <code>array[2*q+1][2*r]</code>
</li>
<li v-bind:class="highlighted.s === 'W'? 'highlight': ''">Store <svg width="1em" height="1em" viewBox="0 0 100 100" style="background:#eee"><rect v-bind:y="100*blend" v-bind:width="100*blend" v-bind:height="100*(1-blend)" class="edge"></rect></svg>  <strong>W edges</strong>  <code>q,r,W</code> in <code>array[2*q][2*r+1]</code>
</li>
<li v-bind:class="highlighted.s === undefined? 'highlight': ''">Store <svg width="1em" height="1em" viewBox="0 0 100 100" style="background:#eee"><rect v-bind:x="100*blend" v-bind:y="100*blend" v-bind:width="100*(1-blend)" v-bind:height="100*(1-blend)" class="tile"></rect></svg>  <strong>tiles</strong>  <code>q,r</code> in <code>array[2*q+1][2*r+1]</code>
</li>
</ul></figure><p>This approach lets you store corners, edges, and tiles all in the same array. I haven't had a use for this in my own projects but I'm including it because it's a neat idea that someone might find useful. Anna Harren has <a href="https://twitter.com/garblefart/status/1151802138244386816">a way to do this with hexagons too!</a><sup class="print-endnote">[1]</sup></p></section><section><h2 id="more">
<span><a href="#more">More</a></span><a class="anchor" href="#more">#</a>
</h2>
<ul>
<li>
<a href="/grids/parts/">My guide to grids</a> covers coordinate systems for tiles, edges, and corners, not only for square grids, but also for hexagonal and triangular grids.</li>
<li>A <a href="https://en.wikipedia.org/wiki/Weighted_Voronoi_diagram">multiplicative voronoi diagram</a><sup class="print-endnote">[2]</sup> can calculate the pixel areas closest to the edges and tiles. We don't need it for the simple case here, but it is useful if you are working with an irregular grid or if you have variably sized objects on your map.</li>
<li>Even though many A* implementations are written to work on the tiles, A* itself cares about both tiles and edges, so it can handle maps where each edge is marked as walkable or not.</li>
<li>David Stark <a href="http://www.zarkonnen.com/grids_in_games">has a blog post about grids in games</a><sup class="print-endnote">[3]</sup>, and points out that Dwarf Fortress uses tile-based walls but edge-based floors.</li>
<li>I've written a quick explanation of <a href="https://twitter.com/redblobgames/status/1494035888749223938">how to detect the diamond shapes around edges using geometry</a><sup class="print-endnote">[4]</sup> but haven't made a full interactive version on this page.</li>
</ul>
<p>Some games, such as Oxygen Not Included and Factory Idle, seem to have a hybrid that keeps track of both tile and edge connections. Some games, such as Factorio and Production Line, have directions along the edges; see <a href="/x/1805-conveyor-belts/">my page about conveyor belts</a>.</p></section></main><div class="below-divider">
<p>Email me <a class="email" rel="me" href="mailto:redblobgames@gmail.com">redblobgames@gmail.com</a>, or comment here:</p>
<div class="print-endnote">
<h3>Links</h3>
<ol>
<li>[1]: https://twitter.com/garblefart/status/1151802138244386816</li>
<li>[2]: https://en.wikipedia.org/wiki/Weighted_Voronoi_diagram</li>
<li>[3]: http://www.zarkonnen.com/grids_in_games</li>
<li>[4]: https://twitter.com/redblobgames/status/1494035888749223938</li>
</ol>
</div>
<div class="comments" role="complementary">
<div id="disqus_thread"><button style="padding:1em;width:100%" onclick="$disqus()">Load comments</button></div>
<script>
function disqus_config(){this.page.url="http://www.redblobgames.com/grids/edges/"}
function $disqus(){$disqus=()=>{};$l("https://redblobgames.disqus.com/embed.js")}
if(document.location.hash.match(/#comment/))setTimeout($disqus,0)
else {new IntersectionObserver(e=>{if(e[0].isIntersecting)$disqus()}).observe(document.getElementById('disqus_thread'))}</script><noscript><a href="https://redblobgames.disqus.com/?url=https://www.redblobgames.com/grids/edges/">View the discussion thread.</a></noscript>
</div>
</div>
<footer><div>
<address>
		  Copyright © <time>2025</time>
                       <a rel="author home copyright" href="https://www.redblobgames.com/">Red Blob Games</a><br><a href="https://www.redblobgames.com/blog/posts.xml"><svg viewBox="0 0 30 30" height="0.8em"><rect width="30" height="30" rx="5" fill="orange"></rect><circle cx="7" cy="23" r="4" fill="white"></circle><path d="M 5,5 A 20,20,0,0,1,25,25 M 5,13 A 12,12,0,0,1,17,25" fill="none" stroke="white" stroke-width="4" stroke-linecap="square"></path></svg>RSS Feed</a>
</address>
<div>
	       <script src="/js/vue.v2.min.js?2022-11-28-15-49-28"></script><script src="grid-edges.js?2020-06-07-16-32-56"></script> Created 15 Jan 2019 with Vue.js;  <!-- hhmts start -->Last modified: 16 Jun 2024<!-- hhmts end -->
</div>
</div></footer>
</body>
</html>
